<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>课程概述</title>
      <link href="/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/05/31/%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h1><h2 id="数字芯片设计流程"><a href="#数字芯片设计流程" class="headerlink" title="数字芯片设计流程"></a>数字芯片设计流程</h2><p>数字芯片的设计，主要是按照以下的顺序来进行的</p><p>定义功能和指标、架构设计，代码设计使用代码描述（verilog 、HDL)、功能验证，这些统称为RTL设计</p><p>RTL设计后，下一步就是把抽象的代码映射成一个跟工艺相关的实际的文件。 这一步就是逻辑综合</p><p>逻辑综合之后，抽象代码就变成了一个由标准单元连接的一个网表，有标准逻辑单元，有连接关系，但是没有确定每一个cell在芯片上的位置坐标。</p><p>逻辑综合之后就是芯片的后端</p><p>在满足功能时序面积约束条件下，把单元放到芯片位置上，这就是full plan 和placement</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598a9f66f0f.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> <img src="https://bu.dusays.com/2024/05/31/66598a9f7139f.png"  alt="十二月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'>  </div><p>根据逻辑单元的连接关系，通过引脚把单元连接起来，也就是布线(Place)</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598a9f67a91.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div><p>如果是一个立体图，可以看到线是分很多层的</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598a9f8e0fd.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div>最后就是整个芯片的样子<div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598aa0310d9.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div><p>我们可以注意到在芯片设计中,memory一般都摆在两边，逻辑单元都在中间</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598aea5f270.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div><h2 id="FPGA设计流程"><a href="#FPGA设计流程" class="headerlink" title="FPGA设计流程"></a>FPGA设计流程</h2><p>第一步也是综合，第二步是实现，和芯片设计流程很相似，也是有布局布线等流程。FPGA设计也需要加入约束来进行设计。</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598a9fc58ea.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div><h2 id="静态时序分析概述"><a href="#静态时序分析概述" class="headerlink" title="静态时序分析概述"></a>静态时序分析概述</h2><p>大部分Soc电路都是很复杂的，大部分可以理解为局部同步，全局异步</p><div class="image-container"><img src="https://bu.dusays.com/2024/05/31/66598a9df0c8b.png"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> </div><p>静态时序分析相比于功能验证的区别</p><p>simulation的测试机理是不停的生成测试向量。静态时序分析不需要生成测试向量，因此静态时序分析的整个时间相对来说就比较短了</p><p>静态时序分析其实是对于simulation的一个非常好的补充。</p>]]></content>
      
      
      <categories>
          
          <category> B站-数字集成电路静态时序分析基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课-数学知识</title>
      <link href="/2024/02/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/02/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<span class="hljs-comment">//不要用开方函数或者i*i小于x。开方函数慢，i*i可能越界</span>        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_prime</span>(x)) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><pre><code class="hljs C++"><span class="hljs-comment">//详细得可以看这个题解：https://www.acwing.com/solution/content/27448/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )<span class="hljs-comment">//i &lt;= x / i:防止越界，速度大于 i &lt; sqrt(x)</span>&#123;        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<span class="hljs-comment">//i为底数</span>        &#123;            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<span class="hljs-comment">//s为指数</span>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;<span class="hljs-comment">//输出</span>        &#125;&#125;    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<span class="hljs-comment">//如果x还有剩余，单独处理</span>    cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        <span class="hljs-built_in">divide</span>(x);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h3><pre><code class="hljs C++"><span class="hljs-comment">//线性法时间复杂度为O(n)</span><span class="hljs-comment">//参考这个链接：https://www.acwing.com/solution/content/7950/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<span class="hljs-type">int</span> primes[N], cnt;<span class="hljs-type">bool</span> st[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )    &#123;        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//用最小质因子去筛合数</span>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-comment">//当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]&lt;i的最小质因子,所以primes[j]*i的最小质因子就是primes[j];</span>            <span class="hljs-comment">//当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该退出循环，避免之后重复进行筛选。</span>        &#125;            &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-built_in">get_primes</span>(n);    cout &lt;&lt; cnt &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> T;    cin &gt;&gt; T;    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-type">int</span> n;        cin &gt;&gt; n;        vector&lt;<span class="hljs-type">int</span>&gt; res;        <span class="hljs-comment">//因为约数成对出现，所以只需要循环到根号x</span>        <span class="hljs-comment">// 不要是用 i *i &lt;= n，因为可能溢出</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n /i; i++)        &#123;            <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)            &#123;                res.<span class="hljs-built_in">push_back</span>(i);                <span class="hljs-comment">//如果i * i = x,添加i即可，不用添加 x / i</span>                <span class="hljs-keyword">if</span>(n / i != i)                    res.<span class="hljs-built_in">push_back</span>(n / i);            &#125;        &#125;        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : res) cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        cout &lt;&lt; endl;    &#125;&#125;</code></pre><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span> ;<span class="hljs-comment">//这题只要是考察约数个数的公式</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> T;     cin &gt;&gt; T;    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; h;    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-type">int</span> n;         cin &gt;&gt; n;        <span class="hljs-comment">//依次求出指数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++)        &#123;            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-comment">//指数+1</span>                h[i] ++;                n = n / i;            &#125;        &#125;        <span class="hljs-comment">//如果有剩余，也是一个质因子</span>        <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) h[n]++;    &#125;    <span class="hljs-type">long</span> <span class="hljs-type">long</span>  res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = h.<span class="hljs-built_in">begin</span>(); iter != h.<span class="hljs-built_in">end</span>(); iter++)    &#123;        <span class="hljs-comment">//res = (x1+1)(x2+1)(x3+1)…(xk+1)</span>        res = res * (iter-&gt;second + <span class="hljs-number">1</span>) % mod ;    &#125;    cout &lt;&lt; res;&#125;</code></pre><h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; primes;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )        &#123;            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>)            &#123;                x /= i;                primes[i] ++ ;            &#125;        &#125;        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) primes[x] ++ ;    &#125;    LL res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : primes)    &#123;        LL a = p.first, b = p.second;        LL t = <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (b -- ) t = (t * a + <span class="hljs-number">1</span>) % mod;<span class="hljs-comment">// x^2 + x = x(x + 1);</span>        <span class="hljs-comment">//计算一下：</span><span class="hljs-comment">//第一步：</span><span class="hljs-comment">//t = (t * a + 1)</span><span class="hljs-comment">//t=p1的一次方+p1的零次方；</span><span class="hljs-comment">//第二步：</span><span class="hljs-comment">//t = (t * a + 1)</span><span class="hljs-comment">//t=p1的二次方+p1的一次方+1=p1的二次方+p1的一次方+p1的零次方；</span>        res = res * t % mod;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><pre><code class="hljs C++"><span class="hljs-comment">//这段算法得代码关键是辗转相除法具体可以参考以下链接：https://www.acwing.com/solution/content/145791/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> T;    cin &gt;&gt; T;    <span class="hljs-keyword">while</span>(T--)    &#123;        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="hljs-comment">//辗转相除，直到小括号内右边数为0</span>        <span class="hljs-keyword">while</span>(b)        &#123;            <span class="hljs-comment">//c 一定小于 b</span>            <span class="hljs-type">int</span> c = a % b;            <span class="hljs-comment">//小括号左边放除数，右边放约数</span>            a = b;            b = c;        &#125;        <span class="hljs-comment">//小括号内左边数为最大公约数</span>        cout &lt;&lt; a &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="欧拉函数-1"><a href="#欧拉函数-1" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><pre><code class="hljs C++"><span class="hljs-comment">//只是一个数学公式具体推导看这个链接就可以：https://www.acwing.com/solution/content/8702/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> res = x;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= x / i; i ++ )        <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)        &#123;            res = res / i * (i - <span class="hljs-number">1</span>);            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) x /= i;        &#125;    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) res = res / x * (x - <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        cin &gt;&gt; x;        cout &lt;&lt; <span class="hljs-built_in">phi</span>(x) &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><pre><code class="hljs C++"><span class="hljs-comment">//不懂的地方看这个代码：https://www.acwing.com/solution/content/3952/</span><span class="hljs-comment">//y总的代码视频讲的也很纤细：https://www.acwing.com/video/299/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000010</span>;<span class="hljs-type">int</span> primes[N], cnt;<span class="hljs-type">int</span> phi[N];<span class="hljs-type">bool</span> st[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_eulers</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><span class="hljs-function"></span>&#123;    phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)    &#123;        <span class="hljs-keyword">if</span> (!st[i])        &#123;            primes[cnt++] = i;            phi[i] = i - <span class="hljs-number">1</span>;         &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j++)        &#123;            st[primes[j] * i] = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>)            &#123;                phi[primes[j] * i] = phi[i] * primes[j];                 <span class="hljs-keyword">break</span>;            &#125;            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="hljs-number">1</span>);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-built_in">get_eulers</span>(n);    LL res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) res += phi[i];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="快速幂-1"><a href="#快速幂-1" class="headerlink" title="快速幂"></a>快速幂</h3><pre><code class="hljs C++"><span class="hljs-comment">//为什么是Logb得时候复杂度，可以看这个链接：https://www.acwing.com/solution/content/15293/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-function">LL <span class="hljs-title">quick</span><span class="hljs-params">(LL a,LL b,LL p)</span><span class="hljs-comment">//二进制，背就完事</span></span><span class="hljs-function"></span>&#123;    LL res=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res=a*res%p; <span class="hljs-comment">//%p都是为了防止溢出操作</span>        a=a*a%p;<span class="hljs-comment">//这里也是，每次乘以得数都不一样</span>        b&gt;&gt;=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )    &#123;        <span class="hljs-type">int</span> a,b,p;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;p);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">quick</span>(a,b,p));    &#125;&#125;</code></pre><h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><pre><code class="hljs C++"><span class="hljs-comment">//不懂的话，看下链接这篇文章就懂了：https://www.acwing.com/problem/content/878/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><span class="hljs-function"></span>&#123;    LL res = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(b)&#123;        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = res * a % p;        a = (LL)a * a % p;        b &gt;&gt;= <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n; cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n --)&#123;        <span class="hljs-type">int</span> a, p;        cin &gt;&gt; a &gt;&gt; p;        <span class="hljs-keyword">if</span>(a % p == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p) &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="扩展欧几里得算法-1"><a href="#扩展欧几里得算法-1" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><pre><code class="hljs C++"><span class="hljs-comment">//详细的过程看看这个代码：https://www.acwing.com/solution/content/1393/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;<span class="hljs-comment">//返回gcd(a,b) 并求出解(引用带回)</span>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-type">int</span> x1,y1,gcd;    gcd = <span class="hljs-built_in">exgcd</span>(b, a%b, x1, y1);    x = y1, y = x1 - a/b*y1;    <span class="hljs-keyword">return</span> gcd; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n,a,b,x,y;    cin&gt;&gt;n;    <span class="hljs-keyword">while</span>(n--)&#123;        cin&gt;&gt;a&gt;&gt;b;        <span class="hljs-built_in">exgcd</span>(a,b,x,y);        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><pre><code class="hljs C++"><span class="hljs-comment">//证明思路看一下这个链接：https://www.acwing.com/solution/content/5937/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span> ;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span>&#123;<span class="hljs-comment">//返回gcd(a,b) 并求出解(引用带回)</span>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-type">int</span> x1,y1,gcd;    gcd = <span class="hljs-built_in">exgcd</span>(b, a%b, x1, y1);    x = y1, y = x1 - a/b*y1;    <span class="hljs-keyword">return</span> gcd; &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n,a,b,x,y,m;    cin&gt;&gt;n;    <span class="hljs-keyword">while</span>(n--)&#123;        cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;        <span class="hljs-type">int</span> d=<span class="hljs-built_in">exgcd</span>(a,m,x,y);        <span class="hljs-keyword">if</span> (b % d) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);        <span class="hljs-keyword">else</span>         &#123;            x = (LL)x * b / d % m;            cout &lt;&lt; x &lt;&lt; endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="表达整数的奇怪方式"><a href="#表达整数的奇怪方式" class="headerlink" title="表达整数的奇怪方式"></a>表达整数的奇怪方式</h3><pre><code class="hljs C++"><span class="hljs-comment">//这个代码看不懂</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-type">int</span> n;<span class="hljs-function">LL <span class="hljs-title">exgcd</span><span class="hljs-params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span>&#123;    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)&#123;        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    LL d = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);    y -= a / b * x;    <span class="hljs-keyword">return</span> d;&#125;<span class="hljs-function">LL <span class="hljs-keyword">inline</span> <span class="hljs-title">mod</span><span class="hljs-params">(LL a, LL b)</span></span>&#123;    <span class="hljs-keyword">return</span> ((a % b) + b) % b;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    LL a1, m1;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a1, &amp;m1);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;        LL a2, m2, k1, k2;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;a2, &amp;m2);        LL d = <span class="hljs-built_in">exgcd</span>(a1, -a2, k1, k2);        <span class="hljs-keyword">if</span>((m2 - m1) % d)&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;        k1 = <span class="hljs-built_in">mod</span>(k1 * (m2 - m1) / d, <span class="hljs-built_in">abs</span>(a2 / d));        m1 = k1 * a1 + m1;        a1 = <span class="hljs-built_in">abs</span>(a1 / d * a2);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, m1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="高斯消元解线性方程组"><a href="#高斯消元解线性方程组" class="headerlink" title="高斯消元解线性方程组"></a>高斯消元解线性方程组</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<span class="hljs-type">int</span> n;<span class="hljs-type">double</span> a[N][N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> c, r;<span class="hljs-comment">// c 代表 列 col ， r 代表 行 row</span>    <span class="hljs-keyword">for</span> (c = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; c &lt; n; c ++ )    &#123;        <span class="hljs-type">int</span> t = r;<span class="hljs-comment">// 先找到当前这一列，绝对值最大的一个数字所在的行号</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; <span class="hljs-built_in">fabs</span>(a[t][c]))                t = i;        <span class="hljs-comment">//这一步就找到了最大的行号</span>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[t][c]) &lt; eps) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt; n + <span class="hljs-number">1</span>; i ++ ) <span class="hljs-built_in">swap</span>(a[t][i], a[r][i]);<span class="hljs-comment">//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];<span class="hljs-comment">// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i ++ )<span class="hljs-comment">// 把当前列下面的所有数，全部消成 0</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][c]) &gt; eps)<span class="hljs-comment">// 如果非0 再操作，已经是 0就没必要操作了</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n; j &gt;= c; j -- )<span class="hljs-comment">// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];</span>                    a[i][j] -= a[r][j] * a[i][c];        r ++ ;<span class="hljs-comment">// 这一行的工作做完，换下一行</span>    &#125;    <span class="hljs-keyword">if</span> (r &lt; n)<span class="hljs-comment">// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解</span>    &#123;<span class="hljs-comment">// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i ++ )<span class="hljs-comment">// </span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(a[i][n]) &gt; eps)<span class="hljs-comment">// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。</span>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程</span>    &#125;    <span class="hljs-comment">//这一步的解释看看这个链接的评论区：https://www.acwing.com/solution/content/5151/</span>    <span class="hljs-comment">// 唯一解 ↓，从下往上回代，得到方程的解</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j ++ )            a[i][n] -= a[j][n] * a[i][j];<span class="hljs-comment">//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n;        <span class="hljs-comment">//处理数据输入</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">1</span>; j ++ )            cin &gt;&gt; a[i][j];    <span class="hljs-type">int</span> t = <span class="hljs-built_in">gauss</span>();    <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf\n&quot;</span>, a[i][n]);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Infinite group solutions&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No solution&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="高斯消元解异或线性方程组"><a href="#高斯消元解异或线性方程组" class="headerlink" title="高斯消元解异或线性方程组"></a>高斯消元解异或线性方程组</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-type">int</span> a[N][N];<span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gauss</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//第一：消成同解的上三角矩阵</span>    <span class="hljs-type">int</span> r, c;    <span class="hljs-comment">//1.枚举列,可以跳过行，但是不能跳过列</span>    <span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>; c &lt; n; c++) &#123;        <span class="hljs-comment">//2.找到剩余行中的非零行</span>        <span class="hljs-type">int</span> t = r;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i++)            <span class="hljs-keyword">if</span> (a[i][c]) &#123;                t = i;                <span class="hljs-keyword">break</span>;            &#125;        <span class="hljs-keyword">if</span> (a[t][c] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-comment">//3.非零行换到剩余行中的最上面</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = c; i &lt;= n; i++) <span class="hljs-built_in">swap</span>(a[r][i], a[t][i]);        <span class="hljs-comment">//4.剩余行中的第c列下面消成0</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r + <span class="hljs-number">1</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">if</span> (a[i][c]) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = c; j &lt;= n; j++)                    a[i][j] ^= a[r][j];            &#125;        &#125;        r++;       &#125;       <span class="hljs-comment">//第二：判断解的情况</span>    <span class="hljs-keyword">if</span> (r &lt; n) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r; i &lt; n; i++)            <span class="hljs-keyword">if</span> (a[i][n])                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;                a[i][n] ^= a[i][j] * a[j][n];            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//int n;</span>    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++)            cin &gt;&gt; a[i][j];    <span class="hljs-type">int</span> res = <span class="hljs-built_in">gauss</span>();    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)            cout &lt;&lt; a[i][n] &lt;&lt; endl;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res == <span class="hljs-number">1</span>)         cout &lt;&lt; <span class="hljs-string">&quot;Multiple sets of solutions&quot;</span>&lt;&lt; endl;    <span class="hljs-keyword">else</span>         cout &lt;&lt;   <span class="hljs-string">&quot;No solution&quot;</span> &lt;&lt; endl;&#125;</code></pre><h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a>求组合数</h2><h3 id="求组合数I"><a href="#求组合数I" class="headerlink" title="求组合数I"></a>求组合数I</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<span class="hljs-type">int</span> c[N][N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++ )        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )            <span class="hljs-keyword">if</span> (!j) c[i][j] = <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % mod;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">init</span>();    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> a, b;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, c[a][b]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课-搜索与图论</title>
      <link href="/2024/01/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/01/30/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10</span>;<span class="hljs-type">int</span> path[N];<span class="hljs-comment">//保存序列</span><span class="hljs-type">int</span> state[N];<span class="hljs-comment">//数字是否被用过</span><span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(u &gt; n)<span class="hljs-comment">//数字填完了，输出</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//输出方案</span>            cout &lt;&lt; path[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        cout &lt;&lt; endl;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//空位上可以选择的数字为:1 ~ n</span>    &#123;        <span class="hljs-keyword">if</span>(!state[i])<span class="hljs-comment">//如果数字 i 没有被用过</span>        &#123;            path[u] = i;<span class="hljs-comment">//放入空位</span>            state[i] = <span class="hljs-number">1</span>;<span class="hljs-comment">//数字被用，修改状态</span>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<span class="hljs-comment">//填下一个位</span>            state[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">//回溯，取出 i 回溯是关键</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);&#125;</code></pre><h3 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h3><pre><code class="hljs C++"><span class="hljs-comment">//cpp</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">11</span>;<span class="hljs-type">char</span> q[N][N];<span class="hljs-comment">//存储棋盘</span><span class="hljs-type">bool</span> dg[N * <span class="hljs-number">2</span>], udg[N * <span class="hljs-number">2</span>], cor[N];<span class="hljs-comment">//点对应的两个斜线以及列上是否有皇后</span><span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(r == n)<span class="hljs-comment">//放满了棋盘，输出棋盘</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)                cout &lt;&lt; q[i][j];            cout &lt;&lt; endl;        &#125;        cout &lt;&lt; endl;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//第 r 行，第 i 列 是否放皇后</span>    &#123;        <span class="hljs-keyword">if</span>(!cor[i] &amp;&amp; !dg[i + r] &amp;&amp; !udg[n - i + r])<span class="hljs-comment">//不冲突，放皇后 </span>        <span class="hljs-comment">//为什么这里能判断，因为同一条斜线上i + j 和 i - j 相等，所以可以这样处理</span>        &#123;            q[r][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;            cor[i] = dg[i + r] = udg[n - i + r] = <span class="hljs-number">1</span>;<span class="hljs-comment">//对应的 列， 斜线 状态改变</span>            <span class="hljs-built_in">dfs</span>(r + <span class="hljs-number">1</span>);<span class="hljs-comment">//处理下一行</span>            cor[i] = dg[i + r] = udg[n - i + r] = <span class="hljs-number">0</span>;<span class="hljs-comment">//恢复现场,为什么要恢复现场，准备下一种情况的输入递归</span>            q[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )            q[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="走迷宫问题"><a href="#走迷宫问题" class="headerlink" title="走迷宫问题"></a>走迷宫问题</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//有没有明白的点可以看这个链接https://www.acwing.com/solution/content/36520/</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//存储地图</span><span class="hljs-type">int</span> f[N][N];<span class="hljs-comment">//存储距离</span><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">//广度优先遍历</span></span><span class="hljs-function"></span>&#123;    queue&lt;PII&gt; q;    q.<span class="hljs-built_in">push</span>(&#123;a, b&#125;);<span class="hljs-comment">//入队</span>    <span class="hljs-comment">//初始点的距离为 0.</span>    <span class="hljs-comment">//可以不要这一句，因为f初始化的时候，各个点为0</span>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())    &#123;        PII start = q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//将队列的第一个元素赋值给start元素</span>        q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//将队首元素移出,这样的操作通常用于处理当前层次的节点</span>        <span class="hljs-comment">//这一句可以不要，因为入队的时候就置为了1</span>        g[start.first][start.second] = <span class="hljs-number">1</span>; <span class="hljs-comment">//是标记当前处理的点 (start.first, start.second) 已经被访问过，避免重复访问</span>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<span class="hljs-comment">//往四个方向走</span>        &#123;            <span class="hljs-comment">//当前点能走到的点</span>            <span class="hljs-type">int</span> x = start.first + dx[i], y = start.second + dy[i]; <span class="hljs-comment">//仔细琢磨这个地方，就可以知道它表示四个移动方向了</span>            <span class="hljs-comment">//如果还没有走过</span>            <span class="hljs-keyword">if</span>(g[x][y] == <span class="hljs-number">0</span>) <span class="hljs-comment">//确定是可以走的</span>            &#123;                <span class="hljs-comment">//走到这个点，并计算距离</span>                g[x][y] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记为已经访问</span>                f[x][y] = f[start.first][start.second] + <span class="hljs-number">1</span>;<span class="hljs-comment">//从当前点走过去，则距离等于当前点的距离+1.</span>                <span class="hljs-comment">//这个点放入队列，用来走到和它相邻的点。</span>                q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<span class="hljs-comment">//将他入队</span>            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m];<span class="hljs-comment">//但是 BFS 本身的性质保证了在搜索过程中首次到达每个点的路径一定是最短路径</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(g)); <span class="hljs-comment">//memset函数，将所有的数组中的元素设置为特定值</span>    cin &gt;&gt; n &gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)        &#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;    <span class="hljs-built_in">bfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);&#125;</code></pre><h3 id="八数码问题"><a href="#八数码问题" class="headerlink" title="八数码问题"></a>八数码问题</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-comment">//不明白可以看这个链接https://www.acwing.com/solution/content/36346/</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// 保存各个序列</span>queue&lt;string&gt; q;string s;<span class="hljs-comment">// 保存序列与对应的交换次数</span>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; h;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 输入原始序列</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)    &#123;        <span class="hljs-type">char</span> c;        cin &gt;&gt; c;        s += c;    &#125;    <span class="hljs-comment">// 保存初始状态</span>    h[s] = <span class="hljs-number">0</span>;    q.<span class="hljs-built_in">push</span>(s);    <span class="hljs-comment">// 定义上下左右四个交换方向</span>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;    <span class="hljs-comment">// 依次进行交换</span>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())    &#123;        <span class="hljs-comment">// 获得当前序列</span>        string t = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-comment">// 如果是最后结果，输出答案</span>        <span class="hljs-keyword">if</span>(t == <span class="hljs-string">&quot;12345678x&quot;</span>)        &#123;            cout &lt;&lt; h[t] &lt;&lt; endl;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">// 找到 x 的位置</span>        <span class="hljs-type">int</span> pos = t.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;x&#x27;</span>);        <span class="hljs-comment">// 计算 x 的坐标</span>        <span class="hljs-type">int</span> a = pos /<span class="hljs-number">3</span> , b = pos % <span class="hljs-number">3</span> ;        <span class="hljs-comment">// 获取当前序列对应的交换次数</span>        <span class="hljs-type">int</span> dist = h[t];        <span class="hljs-comment">// 尝试和四个方向的元素进行交换</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)        &#123;            <span class="hljs-type">int</span> x = a + dx[i], y = b + dy[i];            <span class="hljs-comment">// 判断是否越界</span>            <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt;= <span class="hljs-number">2</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt;= <span class="hljs-number">2</span>)            &#123;                <span class="hljs-comment">// 交换</span>                <span class="hljs-built_in">swap</span>(t[pos], t[<span class="hljs-number">3</span> * x + y]);<span class="hljs-comment">//这里这个t[3*x+y]是指的在一维中的索引位置</span>                <span class="hljs-comment">// 如果是个新序列，就保存新序列和对应的交换次数</span>                <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">find</span>(t) == h.<span class="hljs-built_in">end</span>())                &#123;                    h[t] = dist + <span class="hljs-number">1</span>;                    q.<span class="hljs-built_in">push</span>(t);                &#125;                <span class="hljs-comment">// 恢复现场，进行下一个方向的交换</span>                <span class="hljs-built_in">swap</span>(t[pos], t[<span class="hljs-number">3</span> * x + y]);<span class="hljs-comment">//交换只是交换位置</span>            &#125;        &#125;    &#125;    <span class="hljs-comment">// 没有得到结果序列，输出-1</span>    cout &lt;&lt; <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="树和图的深度优先遍历"><a href="#树和图的深度优先遍历" class="headerlink" title="树和图的深度优先遍历"></a>树和图的深度优先遍历</h2><h3 id="树的重心问题"><a href="#树的重心问题" class="headerlink" title="树的重心问题"></a>树的重心问题</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//这个题目的代码我真的很迷，看了一个多小时都有点摸不着头脑</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>; <span class="hljs-comment">//数据范围是10的5次方</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2</span> * N; <span class="hljs-comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span><span class="hljs-type">int</span> h[N]; <span class="hljs-comment">//邻接表存储树，有n个节点，所以需要n个队列头节点</span><span class="hljs-type">int</span> e[M]; <span class="hljs-comment">//存储元素</span><span class="hljs-type">int</span> ne[M]; <span class="hljs-comment">//存储列表的next值</span><span class="hljs-type">int</span> idx; <span class="hljs-comment">//单链表指针</span><span class="hljs-type">int</span> n; <span class="hljs-comment">//题目所给的输入，n个节点</span><span class="hljs-type">int</span> ans = N; <span class="hljs-comment">//表示重心的所有的子树中，最大的子树的结点数目</span><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">//记录节点是否被访问过，访问过则标记为true</span><span class="hljs-comment">//a所对应的单链表中插入b  a作为根 </span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;<span class="hljs-comment">// dfs 框架</span><span class="hljs-comment">/*</span><span class="hljs-comment">void dfs(int u)&#123;</span><span class="hljs-comment">    st[u]=true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程</span><span class="hljs-comment">    for(int i=h[u];i!=-1;i=ne[i])&#123;</span><span class="hljs-comment">        int j=e[i];</span><span class="hljs-comment">        if(!st[j]) &#123;</span><span class="hljs-comment">            dfs(j);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">//返回以u为根的子树中节点的个数，包括u节点</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储 删掉某个节点之后，最大的连通子图节点数</span>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//标记访问过u节点</span>    <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>; <span class="hljs-comment">//存储 以u为根的树 的节点数, 包括u，如图中的4号节点</span>    <span class="hljs-comment">//访问u的每个子节点</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;        <span class="hljs-type">int</span> j = e[i];        <span class="hljs-comment">//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过</span>        <span class="hljs-keyword">if</span> (!st[j]) &#123;            <span class="hljs-type">int</span> s = <span class="hljs-built_in">dfs</span>(j);  <span class="hljs-comment">// u节点的单棵子树节点数 如图中的size值</span>            res = <span class="hljs-built_in">max</span>(res, s); <span class="hljs-comment">// 记录最大联通子图的节点数</span>            sum += s; <span class="hljs-comment">//以j为根的树的节点数</span>        &#125;    &#125;    <span class="hljs-comment">//n-sum 如图中的n-size值，不包括根节点4；</span>    res = <span class="hljs-built_in">max</span>(res, n - sum); <span class="hljs-comment">// 选择u节点为重心，最大的 连通子图节点数</span>    ans = <span class="hljs-built_in">min</span>(res, ans); <span class="hljs-comment">//遍历过的假设重心中，最小的最大联通子图的节点数</span>    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">//初始化h数组 -1表示尾节点</span>    cin &gt;&gt; n; <span class="hljs-comment">//表示树的结点数</span>    <span class="hljs-comment">// 题目接下来会输入，n-1行数据，</span>    <span class="hljs-comment">// 树中是不存在环的，对于有n个节点的树，必定是n-1条边</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a); <span class="hljs-comment">//无向图</span>    &#125;    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//可以任意选定一个节点开始 u&lt;=n</span>    cout &lt;&lt; ans &lt;&lt; endl;<span class="hljs-comment">//最后是输出ans我终于悟了</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">/*</span><span class="hljs-comment">它这里实际上没有删除这个概念，它就只是，找到树中的一个节点，把它一分为二，位于它下面的，和除了“从此点蔓延下去的树（包括此点）”之外的所有节点，对于它下面的这类，处理是用一个for循环遍历和此点的所有出度，找到其中节点数，也就是联通量最大的一颗子树，记录下来，然后用这颗树总的节点数减去这颗最大的子树节点，再减一，也就是减去当前的节点，得到的值就是除了“从此点蔓延下去的树（包括此点）”之外的所有节点，取个min，就是答案了，每一个点一分为二后的最优解都会存到全局变量里，也就是每一次的dfs执行，都会将当前这个点的最大联通量与全局最优联通量比较，自然执行完所有dfs，此时的全局变量就是我们的答案。</span><span class="hljs-comment">说起来有点绕，其实要想明白它每一次往下递归调用dfs，不仅仅是在算子树的节点大小，同时也在并行处理当前被dfs的这个节点它的最优解，就行了,最后输出的是ans</span><span class="hljs-comment">*/</span></code></pre><h2 id="树和图的广度优先遍历"><a href="#树和图的广度优先遍历" class="headerlink" title="树和图的广度优先遍历"></a>树和图的广度优先遍历</h2><h3 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h3><pre><code class="hljs C++"><span class="hljs-comment">//简单的广度优先遍历问题</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> h[N],ne[N], e[N], idx;<span class="hljs-comment">//邻接表数据结构</span><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//存储距离</span><span class="hljs-type">int</span> st[N];<span class="hljs-comment">//标记点是否走到过</span><span class="hljs-type">int</span> n, m;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">//邻接表存储图</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//初始都没有走到过，距离无穷大</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从1号节点开始，距离为0</span>    queue&lt;<span class="hljs-type">int</span>&gt; q;<span class="hljs-comment">//队列</span>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//1号节点入队列</span>    st[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1到1的距离为0，已经求出</span>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<span class="hljs-comment">//对列非空，就一直往后搜索</span>    &#123;        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<span class="hljs-comment">//队头出队，找该点能到的点</span>        q.<span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<span class="hljs-comment">//遍历所有t节点能到的点，i为节点索引</span>        &#123;            <span class="hljs-type">int</span> j = e[i];<span class="hljs-comment">//通过索引i得到t能到的节点编号</span>            <span class="hljs-keyword">if</span>(!st[j])<span class="hljs-comment">//如果没有遍历过</span>            &#123;                dist[j] = dist[t] + <span class="hljs-number">1</span>;<span class="hljs-comment">//距离为t号节点的距离+1</span>                q.<span class="hljs-built_in">push</span>(j);<span class="hljs-comment">//节点入队</span>                st[j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//入队后标记，已经遍历过了</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n &gt;&gt;m;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化，所有节点没有后继，后继都是-1</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<span class="hljs-comment">//读入所有边</span>    &#123;        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="hljs-built_in">add</span>(a, b);<span class="hljs-comment">//加入邻接表</span>    &#125;    <span class="hljs-built_in">bfs</span>();<span class="hljs-comment">//广度优先遍历</span>    cout &lt;&lt; (dist[n] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : dist[n]);<span class="hljs-comment">//如果到n号节点的距离不是无穷大，输出距离，如果是无穷大，输出-1.</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="有向图的拓扑序列"><a href="#有向图的拓扑序列" class="headerlink" title="有向图的拓扑序列"></a>有向图的拓扑序列</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">//有疑问看这个链接：https://www.acwing.com/solution/content/103954/</span><span class="hljs-type">int</span> e[N], ne[N], idx;<span class="hljs-comment">//邻接表存储图</span><span class="hljs-type">int</span> h[N];<span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队列保存入度为0的点，也就是能够输出的点，</span><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//保存图的点数和边数</span><span class="hljs-type">int</span> d[N];<span class="hljs-comment">////保存各个点的入度</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">//遍历一遍顶点的入度。</span>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果入度为 0, 则可以入队列</span>            q[++tt] = i;    &#125;    <span class="hljs-keyword">while</span>(tt &gt;= hh)&#123;<span class="hljs-comment">//循环处理队列中点的</span>        <span class="hljs-type">int</span> a = q[hh++];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[a]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<span class="hljs-comment">//循环删除 a 发出的边</span>            <span class="hljs-type">int</span> b = e[i];<span class="hljs-comment">//a 有一条边指向b</span>            d[b]--;<span class="hljs-comment">//删除边后，b的入度减1</span>            <span class="hljs-keyword">if</span>(d[b] == <span class="hljs-number">0</span>)<span class="hljs-comment">//如果b的入度减为 0,则 b 可以输出，入队列</span>                q[++tt] = b;        &#125;    &#125;    <span class="hljs-keyword">if</span>(tt == n - <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<span class="hljs-comment">//队列中保存了所有入度为0的点，依次输出</span>            cout &lt;&lt; q[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;        &#125;    &#125;    <span class="hljs-keyword">else</span><span class="hljs-comment">//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序</span>        cout &lt;&lt; <span class="hljs-number">-1</span>;<span class="hljs-comment">//输出-1，代表错误</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; n &gt;&gt; m;<span class="hljs-comment">//保存点的个数和边的个数</span>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化邻接矩阵</span>    <span class="hljs-keyword">while</span> (m -- )&#123;<span class="hljs-comment">//依次读入边</span>        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        d[b]++;<span class="hljs-comment">//顶点b的入度+1</span>        <span class="hljs-built_in">add</span>(a, b);<span class="hljs-comment">//添加到邻接矩阵</span>    &#125;    <span class="hljs-built_in">topsort</span>();<span class="hljs-comment">//进行拓扑排序</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Dijstra"><a href="#Dijstra" class="headerlink" title="Dijstra"></a>Dijstra</h2><h3 id="Dijstra求最短路径I"><a href="#Dijstra求最短路径I" class="headerlink" title="Dijstra求最短路径I"></a>Dijstra求最短路径I</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> h[N], e[M], ne[M], w[M], idx;<span class="hljs-comment">//邻接表存储图</span><span class="hljs-type">int</span> state[N];<span class="hljs-comment">//state 记录是否找到了源点到该节点的最短距离</span><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//dist 数组保存源点到其余各个节点的距离</span><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//图的节点个数和边数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span><span class="hljs-comment">//插入边</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));<span class="hljs-comment">//dist 数组的各个元素为无穷大</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//源点到源点的距离为置为 0</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)    &#123;        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t</span>        &#123;            <span class="hljs-keyword">if</span> (!state[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))                t = j;        &#125;        state[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">//state[i] 置为 1。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = h[t]; j != <span class="hljs-number">-1</span>; j = ne[j])<span class="hljs-comment">//遍历 t 所有可以到达的节点 i</span>        &#123;            <span class="hljs-type">int</span> i = e[j];            dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + w[j]);<span class="hljs-comment">//更新 dist[j]</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));<span class="hljs-comment">//邻接表初始化</span>    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">while</span> (m--)<span class="hljs-comment">//读入 m 条边</span>    &#123;        <span class="hljs-type">int</span> a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        <span class="hljs-built_in">add</span>(a, b, w);    &#125;    <span class="hljs-built_in">Dijkstra</span>();    <span class="hljs-keyword">if</span> (dist[n] != <span class="hljs-number">0x3f3f3f3f</span>)<span class="hljs-comment">//如果dist[n]被更新了，则存在路径</span>        cout &lt;&lt; dist[n];    <span class="hljs-keyword">else</span>        cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;&#125;</code></pre><h3 id="Dijstra求最短路径II"><a href="#Dijstra求最短路径II" class="headerlink" title="Dijstra求最短路径II"></a>Dijstra求最短路径II</h3><pre><code class="hljs C++"><span class="hljs-comment">//利用小根堆寻找最短距离点</span><span class="hljs-comment">//priority_queue：是C++标准库中的优先队列类模板，实现了一个堆（heap）数据结构。</span><span class="hljs-comment">//更多详细的解释可以看这个链接：https://www.acwing.com/solution/content/38318/</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span><span class="hljs-comment">//堆的头文件</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<span class="hljs-comment">//堆里存储距离和节点编号</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<span class="hljs-type">int</span> n, m;<span class="hljs-comment">//节点数量和边数</span><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="hljs-comment">//邻接表存储图</span><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//存储距离</span><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//存储状态</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//距离初始化为无穷大</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="hljs-comment">//小根堆</span>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<span class="hljs-comment">//插入距离和节点编号</span>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//取距离源点最近的点</span>        heap.<span class="hljs-built_in">pop</span>();        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<span class="hljs-comment">//ver:节点编号，distance:源点距离ver 的距离</span>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果距离已经确定，则跳过该点</span>        st[ver] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<span class="hljs-comment">//更新ver所指向的节点距离</span>        &#123;            <span class="hljs-type">int</span> j = e[i];            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] = dist[ver] + w[i];                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<span class="hljs-comment">//距离变小，则入堆</span>            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> dist[n];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        <span class="hljs-built_in">add</span>(a, b, c);    &#125;    cout &lt;&lt; <span class="hljs-built_in">dijkstra</span>() &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><h3 id="有边数限制的最短路"><a href="#有边数限制的最短路" class="headerlink" title="有边数限制的最短路"></a>有边数限制的最短路</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;    <span class="hljs-type">int</span> a;    <span class="hljs-type">int</span> b;    <span class="hljs-type">int</span> w;&#125; e[M];<span class="hljs-comment">//把每个边保存下来即可</span><span class="hljs-type">int</span> dist[N];<span class="hljs-type">int</span> back[N];<span class="hljs-comment">//备份数组防止串联</span><span class="hljs-type">int</span> n, m, k;<span class="hljs-comment">//k代表最短路径最多包涵k条边</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<span class="hljs-comment">//k次循环 ，每一次循环都遍历所有的边</span>        <span class="hljs-built_in">memcpy</span>(back, dist, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//的memcpy函数，其目的是将存储在dist数组中的数据复制到back数组中。具体而言，memcpy用于在内存之间复制一定数量的字节。在这里，back是目标数组，dist是源数组，sizeof dist表示要复制的字节数，即dist数组的大小。</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<span class="hljs-comment">//遍历所有边</span>            <span class="hljs-type">int</span> a = e[j].a, b = e[j].b, w = e[j].w;            dist[b] = <span class="hljs-built_in">min</span>(dist[b], back[a] + w);            <span class="hljs-comment">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-type">int</span> a, b, w;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);        e[i] = &#123;a, b, w&#125;;    &#125;    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bellman_ford</span>();    <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);    <span class="hljs-keyword">else</span> cout &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><h3 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//和bellman-ford区别就在于，它更新最短路径时，没有纯暴力，采取了如果有变化就加入队列的方式</span><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> h[N], e[N], w[N], ne[N], idx;<span class="hljs-comment">//邻接表，存储图</span><span class="hljs-type">int</span> st[N];<span class="hljs-comment">//标记顶点是不是在队列中</span><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//保存最短路径的值</span><span class="hljs-type">int</span> q[N], hh, tt = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队列</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span>&#123;<span class="hljs-comment">//图中添加边和边的端点</span>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span>&#123;    q[++tt] = <span class="hljs-number">1</span>;<span class="hljs-comment">//从1号顶点开始松弛，1号顶点入队</span>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//1号到1号的距离为 0</span>    st[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<span class="hljs-comment">//1号顶点在队列中</span>    <span class="hljs-keyword">while</span>(tt &gt;= hh)&#123;<span class="hljs-comment">//不断进行松弛</span>        <span class="hljs-type">int</span> a = q[hh++];<span class="hljs-comment">//取对头记作a，进行松弛</span>        st[a] = <span class="hljs-number">0</span>;<span class="hljs-comment">//取完队头后，a不在队列中了</span>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[a]; i != <span class="hljs-number">-1</span>; i = ne[i])<span class="hljs-comment">//遍历所有和a相连的点</span>        &#123;            <span class="hljs-type">int</span> b = e[i], c = w[i];<span class="hljs-comment">//获得和a相连的点和边</span>            <span class="hljs-keyword">if</span>(dist[b] &gt; dist[a] + c)&#123;<span class="hljs-comment">//如果可以距离变得更短，则更新距离</span>                dist[b] = dist[a] + c;<span class="hljs-comment">//更新距离</span>                <span class="hljs-keyword">if</span>(!st[b])&#123;<span class="hljs-comment">//如果没在队列中</span>                    q[++tt] = b;<span class="hljs-comment">//入队</span>                    st[b] = <span class="hljs-number">1</span>;<span class="hljs-comment">//打标记</span>                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化邻接表</span>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//初始化距离</span>    <span class="hljs-type">int</span> n, m;<span class="hljs-comment">//保存点的数量和边的数量</span>    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<span class="hljs-comment">//读入每条边和边的端点</span>        <span class="hljs-type">int</span> a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        <span class="hljs-built_in">add</span>(a, b, w);<span class="hljs-comment">//加入到邻接表</span>    &#125;    <span class="hljs-built_in">spfa</span>();    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span> )<span class="hljs-comment">//如果到n点的距离是无穷，则不能到达 </span>        cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;    <span class="hljs-keyword">else</span> cout &lt;&lt; dist[n];<span class="hljs-comment">//否则能到达，输出距离</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="spfa求负环"><a href="#spfa求负环" class="headerlink" title="spfa求负环"></a>spfa求负环</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2010</span>, M = <span class="hljs-number">10010</span>;<span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> h[N], w[M], e[M], ne[M], idx;<span class="hljs-type">int</span> dist[N], cnt[N];<span class="hljs-type">bool</span> st[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    queue&lt;<span class="hljs-type">int</span>&gt; q;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )    &#123;        st[i] = <span class="hljs-literal">true</span>;        q.<span class="hljs-built_in">push</span>(i);    &#125;    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())    &#123;        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();        q.<span class="hljs-built_in">pop</span>();        st[t] = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])        &#123;            <span class="hljs-type">int</span> j = e[i];            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//如果路径的长度大于等于n，就说明存在负环</span>                <span class="hljs-keyword">if</span> (!st[j])                &#123;                    q.<span class="hljs-built_in">push</span>(j);                    st[j] = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    <span class="hljs-comment">//求负环不需要初始化距离，因为不是求取最短路径</span>    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> a, b, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);        <span class="hljs-built_in">add</span>(a, b, c);    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><h3 id="Floyd求最短路"><a href="#Floyd求最短路" class="headerlink" title="Floyd求最短路"></a>Floyd求最短路</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>, M = <span class="hljs-number">2e+10</span>, INF = <span class="hljs-number">1e9</span>;<span class="hljs-type">int</span> n, m, k, x, y, z;<span class="hljs-type">int</span> d[N][N];<span class="hljs-comment">//floyd算法很简单，思路在胡凡算法笔记的398页解释的非常透彻且详细</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)            <span class="hljs-keyword">if</span>(i == j) d[i][j] = <span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span> d[i][j] = INF;    <span class="hljs-keyword">while</span>(m--) &#123;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        d[x][y] = <span class="hljs-built_in">min</span>(d[x][y], z);        <span class="hljs-comment">//注意保存最小的边</span>    &#125;    <span class="hljs-built_in">floyd</span>();    <span class="hljs-keyword">while</span>(k--) &#123;        cin &gt;&gt; x &gt;&gt; y;        <span class="hljs-keyword">if</span>(d[x][y] &gt; INF/<span class="hljs-number">2</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);        <span class="hljs-comment">//由于有负权边存在所以约大过INF/2也很合理</span>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[x][y] &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><h3 id="Prim算法求最小生成树"><a href="#Prim算法求最小生成树" class="headerlink" title="Prim算法求最小生成树"></a>Prim算法求最小生成树</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//存储图</span><span class="hljs-type">int</span> dt[N];<span class="hljs-comment">//存储各个节点到生成树的距离</span><span class="hljs-type">int</span> st[N];<span class="hljs-comment">//节点是否被加入到生成树中</span><span class="hljs-type">int</span> pre[N];<span class="hljs-comment">//节点的前去节点</span><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//n 个节点，m 条边</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(dt,<span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dt));<span class="hljs-comment">//初始化距离数组为一个很大的数（10亿左右）</span>    <span class="hljs-type">int</span> res= <span class="hljs-number">0</span>;    dt[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//从 1 号节点开始生成 </span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<span class="hljs-comment">//每次循环选出一个点加入到生成树</span>    &#123;        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<span class="hljs-comment">//每个节点一次判断</span>        &#123;            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dt[j] &lt; dt[t]))<span class="hljs-comment">//如果没有在树中，且到树的距离最短，则选择该点</span>                t = j;        &#125;        <span class="hljs-comment">//2022.6.1 发现测试用例加强后，需要判断孤立点了</span>        <span class="hljs-comment">//如果孤立点，直返输出不能，然后退出</span>        <span class="hljs-keyword">if</span>(dt[t] == <span class="hljs-number">0x3f3f3f3f</span>) &#123;            cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;            <span class="hljs-keyword">return</span>;        &#125;        st[t] = <span class="hljs-number">1</span>;<span class="hljs-comment">// 选择该点</span>        res += dt[t];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//更新生成树外的点到生成树的距离</span>        &#123;            <span class="hljs-keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])<span class="hljs-comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span>            &#123;                dt[i] = g[t][i];<span class="hljs-comment">//更新距离</span>                pre[i] = t;<span class="hljs-comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span>            &#125;        &#125;    &#125;    cout &lt;&lt; res;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPath</span><span class="hljs-params">()</span><span class="hljs-comment">//输出各个边</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">1</span>; i--)<span class="hljs-comment">//n 个节点，所以有 n-1 条边。</span>    &#123;        cout &lt;&lt; i &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; pre[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>&lt;&lt; endl;<span class="hljs-comment">// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(g));<span class="hljs-comment">//各个点之间的距离初始化成很大的数</span>    cin &gt;&gt; n &gt;&gt; m;<span class="hljs-comment">//输入节点数和边数</span>    <span class="hljs-keyword">while</span>(m --)    &#123;        <span class="hljs-type">int</span> a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<span class="hljs-comment">//输出边的两个顶点和权重</span>        g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],w);<span class="hljs-comment">//存储权重</span>    &#125;    <span class="hljs-built_in">prim</span>();<span class="hljs-comment">//求最下生成树</span>    <span class="hljs-comment">//getPath();//输出路径</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><h3 id="算法求最小生成树"><a href="#算法求最小生成树" class="headerlink" title="算法求最小生成树"></a>算法求最小生成树</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> p[N];<span class="hljs-comment">//保存并查集</span><span class="hljs-comment">//并查集判断是否构成回路</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">E</span>&#123;    <span class="hljs-type">int</span> a;    <span class="hljs-type">int</span> b;    <span class="hljs-type">int</span> w;    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> E&amp; rhs)&#123;<span class="hljs-comment">//通过边长进行排序</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;w &lt; rhs.w;    &#125;&#125;edg[N * <span class="hljs-number">2</span>];<span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<span class="hljs-comment">//并查集找祖宗</span>    <span class="hljs-keyword">if</span>(p[a] != a) p[a] = <span class="hljs-built_in">find</span>(p[a]);    <span class="hljs-keyword">return</span> p[a];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">klskr</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<span class="hljs-comment">//依次尝试加入每条边</span>    &#123;        <span class="hljs-type">int</span> pa = <span class="hljs-built_in">find</span>(edg[i].a);<span class="hljs-comment">// a 点所在的集合</span>        <span class="hljs-type">int</span> pb = <span class="hljs-built_in">find</span>(edg[i].b);<span class="hljs-comment">// b 点所在的集合</span>        <span class="hljs-keyword">if</span>(pa != pb)&#123;<span class="hljs-comment">//如果 a b 不在一个集合中</span>            res += edg[i].w;<span class="hljs-comment">//a b 之间这条边要</span>            p[pa] = pb;<span class="hljs-comment">// 合并a b</span>            cnt ++; <span class="hljs-comment">// 保留的边数量+1</span>        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) p[i] = i;<span class="hljs-comment">//初始化并查集</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<span class="hljs-comment">//读入每条边</span>        <span class="hljs-type">int</span> a, b , c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;        edg[i] = &#123;a, b, c&#125;;    &#125;    <span class="hljs-built_in">sort</span>(edg + <span class="hljs-number">1</span>, edg + m + <span class="hljs-number">1</span>);<span class="hljs-comment">//按边长排序</span>    <span class="hljs-built_in">klskr</span>();    <span class="hljs-comment">//如果保留的边小于点数-1，则不能连通</span>    <span class="hljs-keyword">if</span>(cnt &lt; n - <span class="hljs-number">1</span>) &#123;        cout&lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    cout &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><h3 id="染色法判定二分图-1"><a href="#染色法判定二分图-1" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span> * <span class="hljs-number">2</span>;<span class="hljs-type">int</span> e[N], ne[N], idx;<span class="hljs-comment">//邻接表存储图</span><span class="hljs-type">int</span> h[N];<span class="hljs-type">int</span> color[N];<span class="hljs-comment">//保存各个点的颜色，0 未染色，1 是红色，2 是黑色</span><span class="hljs-type">int</span> n, m;<span class="hljs-comment">//点和边</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><span class="hljs-comment">//邻接表插入点和边</span></span><span class="hljs-function"></span>&#123;    e[idx] = b, ne[idx]= h[a], h[a] = idx++;&#125;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> c)</span><span class="hljs-comment">//深度优先遍历</span></span><span class="hljs-function"></span>&#123;    color[u] = c;<span class="hljs-comment">//u的点成 c 染色</span>    <span class="hljs-comment">//遍历和 u 相邻的点</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i!= <span class="hljs-number">-1</span>; i = ne[i])    &#123;        <span class="hljs-type">int</span> b = e[i];                           <span class="hljs-keyword">if</span>(!color[b])<span class="hljs-comment">//相邻的点没有颜色,则递归处理这个相邻点</span>        &#123;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(b, <span class="hljs-number">3</span> - c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span>                                            <span class="hljs-comment">//（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span>        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[b] &amp;&amp; color[b] != <span class="hljs-number">3</span> - c)<span class="hljs-comment">//如果已经染色，判断颜色是否为 3 - c</span>        &#123;                                                 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果不是，说明冲突，返回                   </span>        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化邻接表</span>    cin &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<span class="hljs-comment">//读入边</span>    &#123;        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="hljs-built_in">add</span>(a, b), <span class="hljs-built_in">add</span>(b, a);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-comment">//遍历点</span>    &#123;        <span class="hljs-keyword">if</span>(!color[i])<span class="hljs-comment">//如果没染色</span>        &#123;            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">1</span>))<span class="hljs-comment">//染色该点，并递归处理和它相邻的点</span>            &#123;                cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//出现矛盾，输出NO </span>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//全部染色完成，没有矛盾，输出YES</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">// 邻接表存储图</span><span class="hljs-type">int</span> n1, n2, m;<span class="hljs-type">int</span> h[<span class="hljs-number">500</span>], e[<span class="hljs-number">100010</span>],ne[<span class="hljs-number">100010</span>], idx = <span class="hljs-number">0</span>;<span class="hljs-comment">//st 标记是否递归找过， match[x]：和 x 编号的男生的编号</span><span class="hljs-type">int</span> st[<span class="hljs-number">510</span>], match[<span class="hljs-number">510</span>];<span class="hljs-comment">//存图函数</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;    e[idx] = b, ne[idx] = h[a]; h[a] = idx++;&#125;<span class="hljs-comment">//递归找可以匹配的点</span><span class="hljs-comment">//详细得思路主要是这个链接：https://www.acwing.com/solution/content/179030/</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    <span class="hljs-comment">// 和各个点尝试能否匹配</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[x]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;        <span class="hljs-type">int</span> b = e[i];        <span class="hljs-keyword">if</span>(!st[b])&#123;<span class="hljs-comment">//打标记</span>            st[b] = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配</span>            <span class="hljs-keyword">if</span>(match[b] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[b]))&#123;<span class="hljs-comment">//注意这里find(match[b]是寻找下一个匹配的女生</span>                <span class="hljs-comment">// 和当前尝试点匹配在一起</span>                match[b] = x;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;    <span class="hljs-comment">// 保存图，因为只从一遍找另一边，所以该无向图只需要存储一个方向</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;        <span class="hljs-type">int</span> a, b;        cin &gt;&gt; a &gt;&gt; b;        <span class="hljs-built_in">add</span>(a, b);    &#125;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-comment">//为各个点找匹配</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++)&#123;        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> st);        <span class="hljs-comment">//找到匹配</span>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(i)) res++;    &#125;    cout &lt;&lt; res;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近</title>
      <link href="/2024/01/26/1.26/"/>
      <url>/2024/01/26/1.26/</url>
      
        <content type="html"><![CDATA[<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>最近的生活感觉特别的迷茫和枯燥，整个人不想奋斗，不想学习，不想游戏，什么都不想，唯一还在坚持做的事情，就是每天去健身房健身了，可能是最近情绪反扑了。最近真的很想陶俊余，但是我很清楚，我们之间是没有再复合的可能性了，中午的时候和段永强一起吃了鸡公煲，我的乖乖，北京的鸡公煲的价格比起四川，真的贵的不是一点半点，真的给我整无语了，坐下差点想走了，不过还是呆在那里继续吃饭了，最近一直在犹豫要不要去重庆找陶俊余的这个事情，设想过很多次从北京到重庆再回来，我心里有时候在想，也许我只是单纯的不甘心吧，但是我也不知道我不甘心啥，很奇怪，你说我去见他毫无意义，难道是去确定一下，她也后悔？她也想我？然后我们也还有可能？但是没有可能了，问题没有解决，就算重新再一起也会分手的，短时间在一起，长时间也会分手的，没有任何意义我觉得，而且主动权也不在我的手上，但是去重庆找她的念头，好像有魔力一样，一发就不可收拾，又找方姐谈了下这个事情，方姐最近应该是很忙，但是还是回复了我，以后还是尽量少打扰人家，也少窥探人家的生活，我是说陶俊余的，但是感觉现在明显比半年前好了，希望再过半年，我可以更好</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>要抓紧了，要好好学习了，不要再荒废时间了，想回家了，这破学校真的一天都呆不下去了，受不了张金豪这个傻逼，世界上怎么会有这么傻逼的人。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm_question</title>
      <link href="/2024/01/21/algorithm_question_summary/"/>
      <url>/2024/01/21/algorithm_question_summary/</url>
      
        <content type="html"><![CDATA[<h1 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h1><p><strong>如何输入多个操作</strong><br>eg:第一行包含整数 N，表示操作数。接下来 N 行，每行包含一个操作指令<br>answer:</p><pre><code class="C++">while (n -- )    &#123;        char op[2];        scanf(&quot;%s%s&quot;,op str);    &#125;```C++</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近</title>
      <link href="/2024/01/19/1.19/"/>
      <url>/2024/01/19/1.19/</url>
      
        <content type="html"><![CDATA[<h2 id="近期感悟"><a href="#近期感悟" class="headerlink" title="近期感悟"></a>近期感悟</h2><p>最近痘痘看了很久的医生。已经消除的差不多了，下一步就是祛痘印的过程，坚持坚持，然后，我今天翻视频发现我好像白了不少，我待会会把视频传上来，最近解锁了一个新的爱好，觉得自己好像真的好喜欢做饭，以后想做一个好的厨师，可能是在成都给陶俊余做了之后，发现自己真的挺喜欢做饭的</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"video":{"url":"/video/1.19.mp4"},"danmaku":{"id":"someid","api":"https://api.prprpr.me/dplayer/","addition":["/some.json"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script> ]]></content>
      
      
      <categories>
          
          <category> 视频记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>健身动作之-手臂篇</title>
      <link href="/2024/01/15/1.15/"/>
      <url>/2024/01/15/1.15/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>手臂分为二头肌和三头肌，所以练手臂用四个动作，两个动作练二头，两个动作练三头</p><h1 id="动作篇"><a href="#动作篇" class="headerlink" title="动作篇"></a>动作篇</h1><h2 id="第一个动作—–哑铃弯举"><a href="#第一个动作—–哑铃弯举" class="headerlink" title="第一个动作—–哑铃弯举"></a>第一个动作—–哑铃弯举</h2><p>首先大臂固定住，发力，然后收到最紧，二头收到最紧的时候停住，然后往下放，放的时候，不要放到完全打直，放到一点点微曲，然后再发力就可以，选择一个重量，然后每组只能做八次到十二次之间，这个重量就是适合你，做完一边，再做另一边，不要交替去做，咱们做的时候，手腕保持中立位，手腕不要往下踏，两边都练完，然后休息40s左右，然后进行下一组就可以了，做四组</p><h2 id="第二个动作—-杠铃弯举"><a href="#第二个动作—-杠铃弯举" class="headerlink" title="第二个动作—-杠铃弯举"></a>第二个动作—-杠铃弯举</h2><p>首先，握距和肩等宽，然后也是大臂固定住发力，收到最紧，然后往下放，放的时候要匀速往下放，不要放的太快，不要晃动，这个也是一组做12个，然后做四组，组间休息50s左右就可以</p><h2 id="第三个动作—–绳索臂屈伸"><a href="#第三个动作—–绳索臂屈伸" class="headerlink" title="第三个动作—–绳索臂屈伸"></a>第三个动作—–绳索臂屈伸</h2><p>首先握住这个两边，然后身体前倾，固定住大臂，三头发力往下压，压的时候，侧面看手臂垂直于地面，然后手臂完全打直就ok,一定要就是尽量打直的时候，两条手臂是平行的，不要怼到一块，顶峰有一个短暂的停留，停留0.5s左右，每组十二次，做四组</p><h2 id="第四个动作—-俯身哑铃臂屈伸"><a href="#第四个动作—-俯身哑铃臂屈伸" class="headerlink" title="第四个动作—-俯身哑铃臂屈伸"></a>第四个动作—-俯身哑铃臂屈伸</h2><p>首先俯身，然后身体呈一个弓箭步，身体不要扭太多，大臂水平与地面不要动，手臂完全打直，放的时候完全放下去，做这个动作一定要把手臂打到最直，越直越好，这样你的三头感觉才会更强，每组做十二次，做四组</p>]]></content>
      
      
      <categories>
          
          <category> 健身 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>健身动作之-练肩篇</title>
      <link href="/2024/01/14/1.14/"/>
      <url>/2024/01/14/1.14/</url>
      
        <content type="html"><![CDATA[<h1 id="动作篇"><a href="#动作篇" class="headerlink" title="动作篇"></a>动作篇</h1><h2 id="第一个动作—-哑铃推举"><a href="#第一个动作—-哑铃推举" class="headerlink" title="第一个动作—-哑铃推举"></a>第一个动作—-哑铃推举</h2><p>哑铃推举的时候，小臂是始终垂直于地面的，推的时候，想象把哑铃往正上方推，推的时候，两个哑铃是微微八字，放的时候，放到耳朵两侧就可以，推的时候再往上推，发力，手臂不要完全打直，只要肩膀收紧就可以，这个时候，前束最受力，从侧面看，肘关节要微微在肩膀的前侧，这样肩关节的压力还是最小，推的时候，从侧面看，小臂始终垂直于地面，坐在凳子上推荐的时候，屁股可以微微往前去一点（也就是往前做一点），去五公分左右，然后背部贴近凳子，做四组，每组12次，组间休息休息到50秒到一分钟都可以。</p><h2 id="第二个动作—–哑铃侧平举"><a href="#第二个动作—–哑铃侧平举" class="headerlink" title="第二个动作—–哑铃侧平举"></a>第二个动作—–哑铃侧平举</h2><p>首先我们拿到哑铃之后，要把哑铃放到大腿前侧，然后沉肩，什么是沉肩，就是耸肩的反义词，沉肩，固定住斜方肌，然后中束发力，记住做的过程中，尽量也不要缩脖子去做，始终往下压着肩，从正面看，肩最高，肘第二，手第三的高度关系不要错，手腕保持中立位置，也不要往下掉，也不用往上飞，中立位就可以，肘在肩膀的前侧，这样去做。每组十二次，做四组</p><h2 id="第三个动作——哑铃俯身飞鸟"><a href="#第三个动作——哑铃俯身飞鸟" class="headerlink" title="第三个动作——哑铃俯身飞鸟"></a>第三个动作——哑铃俯身飞鸟</h2><p>做这个动作，有一个点就很重要，就是要控制住肩胛骨，推出去含胸，是肩胛骨打开的一个状态，咱们做哑铃俯身飞鸟的时候，，就要保持肩胛骨始终打开的这样一个状态，这样才能更好的刺激我们的这个后束，咱们首先要找到一个凳子，屁股尽量往前坐，腿部下面留有足够的空间，然后俯身，肩胛骨打开，保持打开这样的一个固定的角度，一直打开，然后后束发力，把哑铃完全收紧，手臂不要完全打直，微曲，每组12次，每次做四组</p>]]></content>
      
      
      <categories>
          
          <category> 健身 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>健身动作之-练背篇</title>
      <link href="/2024/01/12/1.12/"/>
      <url>/2024/01/12/1.12/</url>
      
        <content type="html"><![CDATA[<h1 id="热身篇"><a href="#热身篇" class="headerlink" title="热身篇"></a>热身篇</h1><p>开肩—-两只手扶着一个杠俯身打开肩胛骨，同时也能适当拉伸一下背阔肌–压十秒钟左右就好</p><h1 id="练背篇"><a href="#练背篇" class="headerlink" title="练背篇"></a>练背篇</h1><h2 id="第一个动作—高位下拉"><a href="#第一个动作—高位下拉" class="headerlink" title="第一个动作—高位下拉"></a>第一个动作—高位下拉</h2><p>首先稳定住自己的下半身，腿卡住，卡紧，完全卡死，然后把肩胛骨往上送，背阔肌拉长，收的时候，肩胛骨下沉，然后拉的时候，把杠拉到自己的锁骨上面。肩胛骨收住</p><p>两个注意点：<br>第一：往下拉的时候，拉到锁骨上方<br>第二：肩胛骨往上放的时候，一定要完全放上去，背阔肌充分拉伸，然后拉的时候，尽量往下夹住，夹到最紧，让行程达到最大化<br>第三：做这个动作可以往后仰，但不能往后太多，微微向后仰一点，收紧就ok<br>第四：因为这是第一个动作，所以我们组数可以做多一点，一般会做到六组，然后重量采用依次递增，这样既能热身，又能激活自己的肌肉，重量可以从四片开始，然后两片两片的加，一直加到第六组，如果加到后面重量加不动了，那就用这个固定的重量一直做到第六组就结束</p><h2 id="第二个动作—坐姿划船"><a href="#第二个动作—坐姿划船" class="headerlink" title="第二个动作—坐姿划船"></a>第二个动作—坐姿划船</h2><p>首先固定好自己的下半身，然后腰部挺直，往前送，把肩胛骨打开送出去，收的时候挺胸，把把手拉到自己的肚子上面，夹肘，肘夹紧挺胸，肩胛骨使劲往后夹收住，这就是顶峰的动作，有一个短暂的停顿0.5s，放身体微前倾，打开肩胛骨收夹肘</p><p>特点：首先要把肩胛骨送出去，让行程达到最大化，然后收的时候就紧贴着身体往后收，夹住，把杠拉到自己肚子上面挺胸，这样背阔肌、大圆肌才能完全收住，这个动作我们需要做四组，然后采用固定重量，次数在八到十二次之间</p><h2 id="第三个动作—-直臂下压"><a href="#第三个动作—-直臂下压" class="headerlink" title="第三个动作—-直臂下压"></a>第三个动作—-直臂下压</h2><p>这个动作也是练背阔肌，大小圆肌的一个动作，首先，身体往后站一点，身体前倾固定住，然后手臂和身体，呈一条直线，尽量拉长自己的背阔肌，收的时候，想象一个画弧的过程，收的时候，前三分之二的路程是直臂，最后曲臂收紧，把杠拉到自己腰带的位置，最后有一个夹背的动作，肩胛骨往后收，肘往后夹</p><p>注意：<br>因为这个动作比较轻松，所以每组需要做12-15次之间</p><h2 id="第四个动作—窄距高位下拉"><a href="#第四个动作—窄距高位下拉" class="headerlink" title="第四个动作—窄距高位下拉"></a>第四个动作—窄距高位下拉</h2><p>首先夹住把手的近端，也就是离你近的这一端，然后肩胛骨往上送，把背阔肌完全拉长，身体微微向后仰挺胸，然后把手拉到自己的胸前，这个时候，腰是一个微微反弓的状态，送上去，这个动作我们选择固定重量，做四组，每组12次就可以</p><h2 id="第五个动作—杠铃俯身划船"><a href="#第五个动作—杠铃俯身划船" class="headerlink" title="第五个动作—杠铃俯身划船"></a>第五个动作—杠铃俯身划船</h2><p>这个动作，也是我们练背当中必不可少的一个动作，首先，俯身屈膝，腰挺直，把力施加在腿后侧链上，减少腰部压力，肩胛骨下沉，把杠铃放出去，收的时候，杠顺着自己大腿的方向，平行往后，夹肘，收肩胛骨，这个杠铃划船我们采用固定的重量，做五组，每组要做到十二次</p><h2 id="第六个动作—宽距坐姿划船"><a href="#第六个动作—宽距坐姿划船" class="headerlink" title="第六个动作—宽距坐姿划船"></a>第六个动作—宽距坐姿划船</h2><p>这个动作，是锻炼我们比较薄弱的中上背<br>注意点：<br>第一：是宽距的，可以用高位下拉的把手<br>第二：拉的时候，拉到胸部的位置，普通的坐姿划船是拉到肚子这里，这个动作就不需要刻意去夹肘了<br>第三：还是腰注意的是，把肩胛骨完全的送到前面，然后收的时候挺胸，肩胛骨使劲向后夹，这样完全夹住，这样才能最大程度的刺激到我们的中背部，这个动作，采用固定的重量，因为重量比较小，所以每组要做到十五次，做四组就结束了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这六个动作，要在90分钟内做完，然后小白组间休息可以到一分钟，新手练背会遇到很多困难，因为手臂借力或者前臂借力等，给新手的建议是，不要依赖助力带</p>]]></content>
      
      
      <categories>
          
          <category> 健身 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>健身动作之-练胸篇</title>
      <link href="/2024/01/11/1.11/"/>
      <url>/2024/01/11/1.11/</url>
      
        <content type="html"><![CDATA[<h1 id="热身篇"><a href="#热身篇" class="headerlink" title="热身篇"></a>热身篇</h1><h2 id="第一个动作"><a href="#第一个动作" class="headerlink" title="第一个动作"></a>第一个动作</h2><p>大臂水平保持不动，小臂往后摆甩–经典招财猫动作–20次为一组，一次一组，可以速度快一点，幅度大一点</p><h2 id="第二个动作"><a href="#第二个动作" class="headerlink" title="第二个动作"></a>第二个动作</h2><p>大臂夹紧身体，小臂往外，往外甩，幅度大一点—20次为一组，一次一组</p><h2 id="第三个动作"><a href="#第三个动作" class="headerlink" title="第三个动作"></a>第三个动作</h2><p>手臂长大点，向前画圆，抡的越圆越大越好—-20圈为一组，一次一组</p><h2 id="第四个动作"><a href="#第四个动作" class="headerlink" title="第四个动作"></a>第四个动作</h2><p>手臂长大点，向后画圆，抡的越圆越大越好—-20圈为一组，一次一组</p><h1 id="练胸篇"><a href="#练胸篇" class="headerlink" title="练胸篇"></a>练胸篇</h1><h2 id="第一个动作—-杠铃平板卧推–黄金动作"><a href="#第一个动作—-杠铃平板卧推–黄金动作" class="headerlink" title="第一个动作—-杠铃平板卧推–黄金动作"></a>第一个动作—-杠铃平板卧推–黄金动作</h2><p>首先，你要找你的眼睛和这个杠的位置，你的眼睛要在这个杠的正下方</p><p>脚微微的往里面收一点，身体成一个反弓的姿态</p><h3 id="如何调整握距"><a href="#如何调整握距" class="headerlink" title="如何调整握距"></a>如何调整握距</h3><p>首先你要保持自己握对称，然后起杠之后，先往下放，放到杠铃触胸的时候，看看小臂是否和杠垂直（这样很重要）</p><h3 id="如何调整手腕"><a href="#如何调整手腕" class="headerlink" title="如何调整手腕"></a>如何调整手腕</h3><p>采用全握，自由重量一定要采用全握，大拇指扣紧，让杠的重量，压在小臂的延长线上</p><h3 id="推举的方式"><a href="#推举的方式" class="headerlink" title="推举的方式"></a>推举的方式</h3><p>杠铃往下放的的时候，放到乳头，上下一两公分的位置都可以，从侧面靠，小臂始终垂直于地面</p><h3 id="身体动作"><a href="#身体动作" class="headerlink" title="身体动作"></a>身体动作</h3><p>推的时候，收紧肩胛骨，肩胛骨微往后夹一点点，肩膀下沉，挺胸，推的时候，手臂不要完全打直，微曲，胸部收紧就可以，放的时候匀速往下放，杠铃的轨迹，你就想象成推的直上直下，大臂和身体的夹角大约是四十五度</p><h3 id="呼吸"><a href="#呼吸" class="headerlink" title="呼吸"></a>呼吸</h3><p>杠下来的时候吸气，发力的时候，吐出去</p><h2 id="第二个动作—蝴蝶机夹胸"><a href="#第二个动作—蝴蝶机夹胸" class="headerlink" title="第二个动作—蝴蝶机夹胸"></a>第二个动作—蝴蝶机夹胸</h2><h3 id="位置调整"><a href="#位置调整" class="headerlink" title="位置调整"></a>位置调整</h3><p>要让你的肩，高于你的手，一拳左右的距离</p><h3 id="身体部位"><a href="#身体部位" class="headerlink" title="身体部位"></a>身体部位</h3><p>手臂全程打直，手臂内侧相对，胸部收紧，肩膀不要往前，肩胛骨微微向后。手臂微曲，始终感觉是挺胸的状态去做，肘向后的时候，手臂不要打太直，发力的时候，手打直，下去的时候手弯曲，也是做4组，每组12次</p><h3 id="第三个动作—哑铃上斜卧推"><a href="#第三个动作—哑铃上斜卧推" class="headerlink" title="第三个动作—哑铃上斜卧推"></a>第三个动作—哑铃上斜卧推</h3><p>肩胛骨向后微微缩紧，手臂打直，将哑铃举起，哑铃微微成八字，往下放，放到胸部两侧，这个时候，大臂和身体，大约是一个45度的角度，垂直往上发力，做四组，每组12次</p>]]></content>
      
      
      <categories>
          
          <category> 健身 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2023年终总结</title>
      <link href="/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/01/2023%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>2023年过的真快，好像去年跨年还在昨天，今天就已经是2024年了，我对2023年做个总结，2023的关键词是失败</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>2023年的生活过的一塌糊涂，从新年的第一天就一直吵架，3月复试失败，4月到六月感情不顺，六月分手到如今，患上了抑郁症，还困在感情里走不出来，至今还在疗伤，2023过的一团糟糕，对于2023年，我对自己的忠告的是，以后做什么决定，一定不要头脑一热就去做，要仔细想，反复想，关于生活的选择，有可能从一开始就决定了一项重大事情的失败，我时常会想，假如当时我选择了向父母要钱，而不是去工作，我和陶俊余，会走到今天这步吗，我想好的心态真的决定了最终问题的走向，所以以后在生活的选择上，一定要好好想，站在十年之后想，十年之后，你会希望自己怎么做，做出怎样的选择，拥有怎么样的人生体验</p><h1 id="事业"><a href="#事业" class="headerlink" title="事业"></a>事业</h1><p>事业坎坎坷坷，复试失败后，居然调剂到了中石油，这辈子没想过来北方，只能说，也许一切冥冥之中自有安排。</p><h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>不要浪费时间，把时间花费在学习，健身，看书上，珍惜人生的每一缕光阴</p><h1 id="长相"><a href="#长相" class="headerlink" title="长相"></a>长相</h1><p>2023的气质变化真的巨大，具体见下图</p><div class="image-container"><img src="https://bu.dusays.com/2024/01/01/65924f2a38843.jpg"  alt="六月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'> <img src="https://bu.dusays.com/2024/01/01/65924acc959d5.jpg"  alt="十二月"  loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'>  </div>]]></content>
      
      
      <categories>
          
          <category> 年终总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新年祝福</title>
      <link href="/2023/12/30/test/"/>
      <url>/2023/12/30/test/</url>
      
        <content type="html"><![CDATA[<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"autoplay":true,"video":{"url":"/video/祝福.mp4"},"danmaku":{"id":"someid","api":"https://api.prprpr.me/dplayer/","addition":["/some.json"]}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script> ]]></content>
      
      
      <categories>
          
          <category> 视频记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课-数据结构</title>
      <link href="/2023/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/12/28/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础课"><a href="#算法基础课" class="headerlink" title="算法基础课"></a>算法基础课</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="C:\Users\HP\Desktop\加速比图片.png" alt="加速比图片" loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><pre><code class="hljs C++">=<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">/*这个题的理解上有一个问题困扰了我很久，就是这个Idx究竟代表什么，翻了很多的评论，我觉得以下这个评论</span><span class="hljs-comment">我觉得很合适说说的我个人对idx的理解</span><span class="hljs-comment">先区分两个概念：</span><span class="hljs-comment">节点和结点</span><span class="hljs-comment">节点：一个点</span><span class="hljs-comment">结点：链表的元素，含e[idx],ne[idx]两个部分</span><span class="hljs-comment">e[idx]:结点编号为idx对应的节点值</span><span class="hljs-comment">ne[idx]：结点编号为idx对应的下一个结点的编号</span><span class="hljs-comment">区分完这两个概念应该能理解idx的作用，为结点编号</span><span class="hljs-comment">我觉得看完这个之后，应该就能很好的理解这个代码</span><span class="hljs-comment">*/</span><span class="hljs-comment">// head 表示头结点的下标</span><span class="hljs-comment">// e[i] 表示节点i的值</span><span class="hljs-comment">// ne[i] 表示节点i的next指针是多少</span><span class="hljs-comment">// idx 存储当前已经用到了哪个点</span><span class="hljs-type">int</span> head, e[N], ne[N], idx;<span class="hljs-comment">// 初始化</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    head = <span class="hljs-number">-1</span>;    idx = <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 将x插到头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x, ne[idx] = head, head = idx ++ ;&#125;<span class="hljs-comment">// 将x插到下标是k的点后面</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;&#125;<span class="hljs-comment">// 将下标是k的点后面的点删掉</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><span class="hljs-function"></span>&#123;    ne[k] = ne[ne[k]];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> m;    cin &gt;&gt; m;    <span class="hljs-built_in">init</span>();    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> k, x;        <span class="hljs-type">char</span> op;        cin &gt;&gt; op;        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;H&#x27;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">add_to_head</span>(x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;D&#x27;</span>)        &#123;            cin &gt;&gt; k;            <span class="hljs-keyword">if</span> (!k) head = ne[head];            <span class="hljs-keyword">else</span> <span class="hljs-built_in">remove</span>(k - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span>        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">add</span>(k - <span class="hljs-number">1</span>, x);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head; i != <span class="hljs-number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">/*</span><span class="hljs-comment">这个题目，初始的时候我看的有点懵逼，在这个模板里，加了两个哑巴结点，这样就能够减少操作，实际上0和1这个结点一直不会被删除，是一个很好的做法</span><span class="hljs-comment">*/</span><span class="hljs-type">int</span> m;<span class="hljs-type">int</span> e[N], l[N], r[N], idx;<span class="hljs-comment">// 在节点a的右边插入一个数x</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;&#125;<span class="hljs-comment">// 删除节点a</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><span class="hljs-function"></span>&#123;    l[r[a]] = l[a];    r[l[a]] = r[a];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; m;    <span class="hljs-comment">// 0是左端点，1是右端点</span>    r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    idx = <span class="hljs-number">2</span>;    <span class="hljs-keyword">while</span> (m -- )    &#123;        string op;        cin &gt;&gt; op;        <span class="hljs-type">int</span> k, x;        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;L&quot;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;R&quot;</span>)        &#123;            cin &gt;&gt; x;            <span class="hljs-built_in">insert</span>(l[<span class="hljs-number">1</span>], x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>)        &#123;            cin &gt;&gt; k;            <span class="hljs-built_in">remove</span>(k + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;IL&quot;</span>)        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">insert</span>(l[k + <span class="hljs-number">1</span>], x);        &#125;        <span class="hljs-keyword">else</span>        &#123;            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-built_in">insert</span>(k + <span class="hljs-number">1</span>, x);        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = r[<span class="hljs-number">0</span>]; i != <span class="hljs-number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//输出的时候也是从r[0]输出，没有输出哑巴结点</span>    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> st[N];<span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<span class="hljs-type">int</span> n;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span>(n--)    &#123;        string s;        cin &gt;&gt; s;        <span class="hljs-comment">//栈顶所在索引往后移动一格，然后放入x。</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)        &#123;            <span class="hljs-type">int</span> a;            cin &gt;&gt; a;            st[++top] = a;        &#125;        <span class="hljs-comment">//往前移动一格</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)        &#123;            top --;        &#125;        <span class="hljs-comment">//返回栈顶元素</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)        &#123;            cout &lt;&lt; st[top] &lt;&lt; endl;        &#125;        <span class="hljs-comment">//大于等于 0 栈非空，小于 0 栈空</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)        &#123;            cout &lt;&lt; (top == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;        &#125;    &#125;&#125;</code></pre><h4 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;stack&lt;<span class="hljs-type">int</span>&gt; num;stack&lt;<span class="hljs-type">char</span>&gt; op;<span class="hljs-comment">//优先级表</span>unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; h&#123; &#123;<span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">2</span>&#125; &#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eval</span><span class="hljs-params">()</span><span class="hljs-comment">//求值</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> a = num.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//第二个操作数</span>    num.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">int</span> b = num.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//第一个操作数</span>    num.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">char</span> p = op.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//运算符</span>    op.<span class="hljs-built_in">pop</span>();    <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<span class="hljs-comment">//结果 </span>    <span class="hljs-comment">//计算结果</span>    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;+&#x27;</span>) r = b + a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;-&#x27;</span>) r = b - a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;*&#x27;</span>) r = b * a;    <span class="hljs-keyword">if</span> (p == <span class="hljs-string">&#x27;/&#x27;</span>) r = b / a;    num.<span class="hljs-built_in">push</span>(r);<span class="hljs-comment">//结果入栈</span>&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string s;<span class="hljs-comment">//读入表达式</span>    cin &gt;&gt; s;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)    &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i]))<span class="hljs-comment">//数字入栈</span>        &#123;            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, j = i;<span class="hljs-comment">//计算数字</span>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[j]))            &#123;                x = x * <span class="hljs-number">10</span> + s[j] - <span class="hljs-string">&#x27;0&#x27;</span>;                j++;            &#125;            <span class="hljs-comment">//这个地方的理解可以看看海绵宝宝题解的第一条评论，写的很好</span>            num.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//数字入栈</span>            i = j - <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">//左括号无优先级，直接入栈</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">//左括号入栈</span>        &#123;            op.<span class="hljs-built_in">push</span>(s[i]);        &#125;        <span class="hljs-comment">//括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-comment">//右括号</span>        &#123;            <span class="hljs-keyword">while</span>(op.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-comment">//一直计算到左括号</span>                <span class="hljs-built_in">eval</span>();            op.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//左括号出栈</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>() &amp;&amp; h[op.<span class="hljs-built_in">top</span>()] &gt;= h[s[i]])<span class="hljs-comment">//待入栈运算符优先级低，则先计算</span>                <span class="hljs-built_in">eval</span>();            op.<span class="hljs-built_in">push</span>(s[i]);<span class="hljs-comment">//操作符入栈</span>        &#125;    &#125;    <span class="hljs-keyword">while</span> (op.<span class="hljs-built_in">size</span>()) <span class="hljs-built_in">eval</span>();<span class="hljs-comment">//剩余的进行计算</span>    cout &lt;&lt; num.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<span class="hljs-comment">//输出结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> q[N];<span class="hljs-comment">//[hh, tt] 之间为队列（左闭右闭）</span><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>;<span class="hljs-comment">//队头位置</span><span class="hljs-type">int</span> tt = <span class="hljs-number">-1</span>;<span class="hljs-comment">//队尾位置</span><span class="hljs-comment">//操作次数</span><span class="hljs-type">int</span> m;<span class="hljs-comment">//操作方式</span>string s;<span class="hljs-comment">//入队：队尾先往后移动一格，再放入要插入的数据</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;    q[++tt] = x;&#125;<span class="hljs-comment">//出队：队头往后移动一格</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;    hh++;&#125;<span class="hljs-comment">//[hh, tt]表示队列区间，当tt &gt;= hh时，区间不为空</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(tt &gt;= hh) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;&#125; <span class="hljs-comment">//hh指向队头，q[hh]代表队头元素</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span> <span class="hljs-params">()</span></span>&#123;    cout &lt;&lt; q[hh] &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    cin &gt;&gt; m;    <span class="hljs-keyword">while</span>(m--)&#123;        cin &gt;&gt; s;        <span class="hljs-comment">//入队</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)&#123;            <span class="hljs-type">int</span> x;            cin &gt;&gt; x;            <span class="hljs-built_in">push</span>(x);        &#125;        <span class="hljs-comment">//出队</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;pop&quot;</span>)&#123;            <span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-comment">//问空</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;empty&quot;</span>)&#123;            <span class="hljs-built_in">empty</span>();        &#125;        <span class="hljs-comment">//问队头</span>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;query&quot;</span>)&#123;            <span class="hljs-built_in">query</span>();        &#125;    &#125;&#125;</code></pre><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> stk[N], tt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">int</span> x;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);        <span class="hljs-keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;        <span class="hljs-keyword">if</span> (!tt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 &quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, stk[tt]);        stk[ ++ tt] = x;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1000100</span>;<span class="hljs-comment">//这段代码中很关键的点在于，q[N]中存的是数组下标，而不是数组元素</span><span class="hljs-comment">//单调队列一般用双端队列保证其单调性</span><span class="hljs-type">int</span> a[N], q[N], n, k;<span class="hljs-comment">//队头和队尾，在队尾插入，队头获取</span><span class="hljs-type">int</span> front = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-comment">//先找每个窗口的最小值</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-comment">//如果当前队头在数组的下标小于当前窗口的最小下标，这个窗口就不包含这个元素了那么无论如何都要剔除队头这个元素</span>        <span class="hljs-comment">//所以要在队头删除这个元素</span>        <span class="hljs-keyword">if</span> (front &lt;= tail &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[front]) front++;        <span class="hljs-comment">//保证单调性，在队尾删除（为什么要在队尾删除，简单来说在队头删除不能保证单调</span>        <span class="hljs-comment">//比如-3 5为当前队列，当前的元素为3，如果在队头操作，那么按照a[i] &lt;= a[q[front]，有3 &gt; -3，因此不做删除操作</span>        <span class="hljs-comment">//但是接下来就出现问题了，3就要入队了。此时队列就是-3 5 3，不符合单调性了！</span>        <span class="hljs-comment">//但如果在队尾操作，按照a[i] &lt;= a[q[tail]，有3 &lt; 5，就要让5出队</span>        <span class="hljs-comment">//之后3入队，队列就是-3 3，满足单调性</span>        <span class="hljs-keyword">while</span> (front &lt;= tail &amp;&amp; a[i] &lt;= a[q[tail]]) tail--;        q[++tail] = i;        <span class="hljs-comment">//队头为窗口的最小值</span>        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[front]]);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-comment">//这次找最大值，同理</span>    front = <span class="hljs-number">0</span>, tail = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">if</span> (front &lt;= tail &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[front]) front++;        <span class="hljs-keyword">while</span> (front &lt;= tail &amp;&amp; a[i] &gt;= a[q[tail]]) tail--;        q[++tail] = i;        <span class="hljs-keyword">if</span> (i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[front]]);    &#125;&#125;</code></pre><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><pre><code class="hljs C++"><span class="hljs-comment">//这段代码我还有很多没明白的地方，回头看看算法笔记</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;<span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> ne[N];<span class="hljs-type">char</span> s[M], p[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;    <span class="hljs-comment">//求next数组</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )    &#123;        <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;        ne[i] = j;    &#125;    <span class="hljs-comment">//匹配代码</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )    &#123;        <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];        <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;        <span class="hljs-keyword">if</span> (j == n)        &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);            j = ne[j];        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="Trie-专门用来处理存储字符串的集合问题"><a href="#Trie-专门用来处理存储字符串的集合问题" class="headerlink" title="Trie  (专门用来处理存储字符串的集合问题)"></a>Trie  (专门用来处理存储字符串的集合问题)</h3><h4 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title="Trie字符串统计"></a>Trie字符串统计</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-comment">//trie树专门用来处理存储字符串的集合问题，如果还是有不懂的地方，参照这篇博客</span><span class="hljs-comment">//https://blog.csdn.net/raelum/article/details/128885107</span><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<span class="hljs-type">char</span> str[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )    &#123;        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    &#125;    cnt[p] ++ ;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )    &#123;        <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;        <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        p = son[p][u];    &#125;    <span class="hljs-keyword">return</span> cnt[p];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, str);        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) <span class="hljs-built_in">insert</span>(str);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(str));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="最大异或对"><a href="#最大异或对" class="headerlink" title="最大异或对"></a>最大异或对</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//有不懂的地方，看这篇博客https://blog.csdn.net/raelum/article/details/128885107</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">3100010</span>;<span class="hljs-type">int</span> n;<span class="hljs-type">int</span> a[N], son[M][<span class="hljs-number">2</span>], idx;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )    &#123;        <span class="hljs-type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (!s) s = ++ idx;        p = s;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i -- )    &#123;        <span class="hljs-type">int</span> s = x &gt;&gt; i &amp; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (son[p][!s])        &#123;            res += <span class="hljs-number">1</span> &lt;&lt; i;<span class="hljs-comment">//这是等于加上2^i次方</span>            p = son[p][!s];        &#125;        <span class="hljs-keyword">else</span> p = son[p][s];    &#125;    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )    &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);        <span class="hljs-built_in">insert</span>(a[i]);    &#125;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">search</span>(a[i]));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="合并集合"><a href="#合并集合" class="headerlink" title="合并集合"></a>合并集合</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> p[N];<span class="hljs-comment">//建立一个父结点数组</span><span class="hljs-type">int</span> n,m;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//find函数，路径压缩</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<span class="hljs-comment">//如果祖宗结点不是自己，那么路径压缩；</span>    <span class="hljs-keyword">return</span> p[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i ++ ) p[i]=i;    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> a,b;        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<span class="hljs-comment">//两个操作</span>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d%d&quot;</span>,op, &amp;a, &amp;b);        <span class="hljs-keyword">if</span>(op[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;M&#x27;</span>) p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title="连通块中点的数量"></a>连通块中点的数量</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> p[N],cnt[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);    <span class="hljs-keyword">return</span> p[x];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )    &#123;        p[i]=i;        cnt[i]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">while</span> (m -- )    &#123;        string op;        cin&gt;&gt;op;        <span class="hljs-type">int</span> a,b;        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;C&quot;</span>)        &#123;            cin &gt;&gt; a&gt;&gt;b;            a=<span class="hljs-built_in">find</span>(a),b=<span class="hljs-built_in">find</span>(b);            <span class="hljs-keyword">if</span>(a!=b)            &#123;                p[a]=b;                cnt[b]+=cnt[a];            &#125;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&quot;Q1&quot;</span>)        &#123;            cin &gt;&gt; a&gt;&gt;b;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);        &#125;        <span class="hljs-keyword">else</span>         &#123;            cin &gt;&gt; a;            <span class="hljs-type">int</span> x=<span class="hljs-built_in">find</span>(a);            cout &lt;&lt; cnt[x]&lt;&lt;endl;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="食物链、"><a href="#食物链、" class="headerlink" title="食物链、"></a>食物链、</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-comment">//这个算法的关键是划分集合,，用距离来判断是否属于同一类，思路实在是很绝，来判断是不是真话，如果有疑问，可以看yxc代码的评论区</span><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> p[N], d[N]; <span class="hljs-comment">//p[]寻找祖宗节点，d[]求到祖宗节点的距离</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (p[x] != x)    &#123;        <span class="hljs-type">int</span> t = <span class="hljs-built_in">find</span>(p[x]); <span class="hljs-comment">// u暂时存一下p[x]根节点，辅助变量</span>        d[x] += d[p[x]];    <span class="hljs-comment">// 更新距离</span>        p[x] = t;    &#125;    <span class="hljs-keyword">return</span> p[x];&#125;<span class="hljs-comment">// 不行，因为这个路径的长度（高度），是需要自上而下加起来的，从根节点往下走</span><span class="hljs-comment">// 所以要先调用递归</span><span class="hljs-comment">// int find(int x)</span><span class="hljs-comment">// &#123;</span><span class="hljs-comment">//     if (p[x] != x)</span><span class="hljs-comment">//     &#123;</span><span class="hljs-comment">//         d[x] += d[p[x]];    // 更新距离</span><span class="hljs-comment">//         p[x] = find(p[x]); </span><span class="hljs-comment">//     &#125;</span><span class="hljs-comment">//     return p[x];</span><span class="hljs-comment">// &#125;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录错误数</span>    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-type">int</span> t, x, y;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;x, &amp;y);        <span class="hljs-keyword">if</span> (x &gt; n || y &gt; n) res ++ ; <span class="hljs-comment">// 当前的话中X或Y比N大，是假话</span>        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-type">int</span> px = <span class="hljs-built_in">find</span>(x), py = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">// 查找根节点</span>            <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) <span class="hljs-comment">// 判断是否同类</span>            &#123;                <span class="hljs-keyword">if</span> (px == py) &#123;  <span class="hljs-comment">// 若 x 与 y 在同一个集合中</span>                    <span class="hljs-keyword">if</span> ((d[x] - d[y]) % <span class="hljs-number">3</span>) res ++ ; <span class="hljs-comment">// 两数到根节点距离之差的模不为 0，说明不是同一类，是假话</span>                    <span class="hljs-comment">// 其中 (d[x] - d[y]) % 3 不可写为 d[x] % 3 != d[y] % 3</span>                    <span class="hljs-comment">// 因为 d[x], d[y] 可能为负数（一正一负），可改做 (d[x] % 3 + 3) % 3 != (d[y] % 3 + 3) % 3</span>                    <span class="hljs-comment">// 负数 mod 正数为负数</span>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 则 x 与 y 不在同一个集合中</span>                    p[px] = py;     <span class="hljs-comment">// x 所在集合 合并到 y 所在集合</span>                    d[px] = d[y] - d[x];<span class="hljs-comment">//这里是先把所有的存到一个集合里的意思，认定没出现在集合里的第一句话为真话</span>                    <span class="hljs-comment">// d[x] 的距离为什么不更新？</span>                    <span class="hljs-comment">// 只是暂时不更新，在调用 find 时再更新</span>                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-comment">// X 是否吃 Y</span>            &#123;                <span class="hljs-keyword">if</span> (px == py) &#123;     <span class="hljs-comment">// 若 x 与 y 在同一个集合中</span>                    <span class="hljs-comment">// 若 X 吃 Y，则 d[x] 比 d[y] 大 1</span>                    <span class="hljs-keyword">if</span> ((d[x] - d[y] - <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>) res ++ ;  <span class="hljs-comment">// 若距离之差 - 1 的模不为 0，说明吃不掉，是假话</span>                &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 则 x 与 y 不在同一个集合中</span>                    p[px] = py;                    <span class="hljs-comment">// (d[x] - d[y] - 1) % 3 == 0</span>                    <span class="hljs-comment">// d[x] + d[px] - 1 = d[y]  则：</span>                    d[px] = d[y] + <span class="hljs-number">1</span> - d[x];<span class="hljs-comment">//这里和上面一样</span>                &#125;            &#125;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-comment">//详细的内容看这个链接：https://www.acwing.com/solution/content/120483/</span><span class="hljs-comment">//以及这个链接：https://raelum.blog.csdn.net/article/details/128800503</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> h[N], cnt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> <span class="hljs-comment">//小根堆的构建方法</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> t = u;    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (u != t)    &#123;        <span class="hljs-built_in">swap</span>(h[u], h[t]);        <span class="hljs-built_in">down</span>(t);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;h[i]);    cnt = n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<span class="hljs-comment">//这样就构建成了一个小根堆</span>    <span class="hljs-keyword">while</span> (m -- )    &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, h[<span class="hljs-number">1</span>]);<span class="hljs-comment">//初始时这个h[1]为什么是最小值</span>        h[<span class="hljs-number">1</span>] = h[cnt -- ];        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);    &#125;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="模拟堆"><a href="#模拟堆" class="headerlink" title="模拟堆"></a>模拟堆</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<span class="hljs-type">int</span> heap[N], cnt;<span class="hljs-type">int</span> ph[N];  <span class="hljs-comment">// 记录第k个插入的元素的下标(次序-&gt;下标)</span><span class="hljs-type">int</span> hp[N];  <span class="hljs-comment">// 记录当前元素下标对应元素插入的次序(也就是第几个插入的 下标-&gt;次序)</span><span class="hljs-comment">/*</span><span class="hljs-comment">    原来交换是直接交换堆中的两个元素，但是本题需要对第k个插入的数修改，</span><span class="hljs-comment">    所以我们需要一个数组ph来存储第k次插入的元素的下标，所以当我们交换两个元素时，</span><span class="hljs-comment">    存储下标的数组对应位置也需要交换，从而保证第k次插入的元素与其下标对应。</span><span class="hljs-comment">    然而由于交换操作传入的是两个元素在堆中的下标，若我们要交换下标记录数组ph数组中对应的下标，</span><span class="hljs-comment">    则需要知道这两个元素是第几个插入的，所以我们需要一个hp数组来存放下标对应元素的插入次序，</span><span class="hljs-comment">    于是当我们交换两个元素时，存储数组元素插入次序的对应位置也需要交换，</span><span class="hljs-comment">    从而保证当前下标对应的元素与其插入次序对应。</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-comment">// 注意不能改为swap(a, b)，因为我们是要将数组ph中保存的两元素的下标进行交换，否则数组ph中的位置并未改变。</span>    <span class="hljs-built_in">swap</span>(ph[hp[a]], ph[hp[b]]);  <span class="hljs-comment">// 先由hp找到对应的插入次序，然后交换ph数组中记录的两个元素的下标</span>    <span class="hljs-built_in">swap</span>(hp[a], hp[b]);         <span class="hljs-comment">// 交换hp数组中记录的两个元素的插入次序</span>    <span class="hljs-built_in">swap</span>(heap[a], heap[b]);    <span class="hljs-comment">// 最后交换堆中的两个元素</span>&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">downAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;    <span class="hljs-type">int</span> m = u;    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= cnt &amp;&amp; heap[u * <span class="hljs-number">2</span>] &lt; heap[m]) m = u * <span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= cnt &amp;&amp; heap[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; heap[m]) m = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span> (u != m) &#123;                   <span class="hljs-comment">// 如果当前结点不为最小结点</span>        <span class="hljs-built_in">heap_swap</span>(u, m);        <span class="hljs-built_in">downAdjust</span>(m);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">upAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; heap[u / <span class="hljs-number">2</span>] &gt; heap[u]) &#123;        <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);        u /= <span class="hljs-number">2</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;                  <span class="hljs-comment">// 记录每个元素插入的次序 </span>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;    cin &gt;&gt; n;    <span class="hljs-keyword">while</span> (n--) &#123;        string op;        cin &gt;&gt; op;        <span class="hljs-type">int</span> x, k;        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;I&quot;</span>) &#123;            <span class="hljs-comment">// 插入一个数x</span>            cin &gt;&gt; x;            cnt++;            index++;                <span class="hljs-comment">// 记录当前元素是第几次插入的</span>            ph[index] = cnt;        <span class="hljs-comment">// 堆尾插入，故第index次插入的元素下标为cnt</span>            hp[cnt] = index;        <span class="hljs-comment">// 当前下标为cnt的元素为第index次插入</span>            heap[cnt]=x;            <span class="hljs-comment">// 记录插入的值(即heap[ph[index]] = x)</span>            <span class="hljs-built_in">upAdjust</span>(cnt);          <span class="hljs-comment">// 从堆尾向上调整</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;PM&quot;</span>) &#123;    <span class="hljs-comment">// 输出当前集合中的最小元素</span>            cout &lt;&lt; heap[<span class="hljs-number">1</span>] &lt;&lt; endl;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;DM&quot;</span>) &#123;    <span class="hljs-comment">// 删除当前集合中的最小值</span>            <span class="hljs-built_in">heap_swap</span>(<span class="hljs-number">1</span>, cnt);      <span class="hljs-comment">// 将堆头元素与堆尾元素交换</span>            cnt--;            <span class="hljs-built_in">downAdjust</span>(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;D&quot;</span>) &#123;     <span class="hljs-comment">// 删除第k个插入的数</span>            cin &gt;&gt; k;            <span class="hljs-comment">/*</span><span class="hljs-comment">                为什么需要用pos保存第k次插入元素的下标？</span><span class="hljs-comment">                因为当我们执行完heap_swap(pos, cnt)操作后，第k次插入元素的下标会变成cnt(即ph[k] = cnt)，</span><span class="hljs-comment">                而我们需要调整的是交换后的原来cnt位置上的元素(其下标变为了pos)，所以需要保存下来。</span><span class="hljs-comment">            */</span>            <span class="hljs-type">int</span> pos = ph[k];        <span class="hljs-comment">// 由插入次序得到在堆中的下标</span>            <span class="hljs-built_in">heap_swap</span>(pos, cnt);    <span class="hljs-comment">// 将第k个插入的数与堆尾元素交换</span>            cnt--;                  <span class="hljs-comment">// 堆容量减一</span>            <span class="hljs-built_in">upAdjust</span>(pos), <span class="hljs-built_in">downAdjust</span>(pos);          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;C&quot;</span>) &#123;     <span class="hljs-comment">// 修改第k个插入的数，将其变为x </span>            cin &gt;&gt; k &gt;&gt; x;            <span class="hljs-type">int</span> pos = ph[k];        <span class="hljs-comment">// 得到第k个插入的元素的下标</span>            heap[pos] = x;          <span class="hljs-comment">// 修改第k个插入的数</span>            <span class="hljs-built_in">upAdjust</span>(pos), <span class="hljs-built_in">downAdjust</span>(pos);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="模拟散列函数"><a href="#模拟散列函数" class="headerlink" title="模拟散列函数"></a>模拟散列函数</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200003</span>, null = <span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-type">int</span> h[N];<span class="hljs-comment">//find 函数实现了开放寻址法的线性探测。首先计算哈希值 t，然后循环查找直到找到空位置或者找到目标值 x。如果找到了空位置，或者找到了目标值 x 所在的位置，返回该位置。</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> t = (x % N + N) % N;    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)     &#123;        t ++ ;        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<span class="hljs-comment">//当遍历到最后一个元素的时候，从头开始寻找</span>    &#125;    <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//用 `memset` 函数将数组 `h` 中的所有元素初始化为 `0x3f3f3f3f`，即 `null`。</span>    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-keyword">while</span> (n -- )    &#123;        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];        <span class="hljs-type">int</span> x;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%d&quot;</span>, op, &amp;x);        <span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) h[<span class="hljs-built_in">find</span>(x)] = x;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">if</span> (h[<span class="hljs-built_in">find</span>(x)] == null) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>,P = <span class="hljs-number">131</span>;<span class="hljs-comment">//131 13331</span>ULL h[N],p[N];<span class="hljs-comment">//可以仔细看这两个链接：https://www.acwing.com/solution/content/24738/</span><span class="hljs-comment">//https://www.acwing.com/solution/content/205524/</span><span class="hljs-comment">// h[i]前i个字符的hash值</span><span class="hljs-comment">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span><span class="hljs-comment">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span><span class="hljs-comment">// 使用场景： 两个字符串的子串是否相同</span><span class="hljs-function">ULL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;    string x;    cin&gt;&gt;x;    <span class="hljs-comment">//字符串从1开始编号，h[1]为前一个字符的哈希值</span>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        p[i+<span class="hljs-number">1</span>] = p[i]*P; <span class="hljs-comment">//求p的多少次方用的，比如p[i]就是p的i次方          </span>        h[i+<span class="hljs-number">1</span>] = h[i]*P +x[i];      <span class="hljs-comment">//前缀和求整个字符串的哈希值</span>        <span class="hljs-comment">//假设字符串为“123”，那h[2]=(1p^2+2p^1+3p^0) 又等于h[1]p+s[2] 即 (1p^1+2p^0)p+3,这里的123其实实际上不是数字，是用它的ASSIC码计算，为了方便理解才直接用数字</span>    &#125;    <span class="hljs-keyword">while</span>(m--)&#123;        <span class="hljs-type">int</span> l1,r1,l2,r2;        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(l1,r1) == <span class="hljs-built_in">query</span>(l2,r2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日学习记录</title>
      <link href="/2023/12/27/11-27/"/>
      <url>/2023/12/27/11-27/</url>
      
        <content type="html"><![CDATA[<p>今天的perl语言看到了第三章，感觉基础概念过一下有个大概印象就好，真正提高代码能力还是得靠后期写项目，因此把书过一遍之后，就去找些项目需求来写，用来提高代码能力<br>shell语言今天把讲义看完了，我觉得学习得时间实在是很紧张，所以我觉得，以后先看讲义，讲义有看不懂的地方就看评论，然后做作业，作业中有不会得地方，再回去看视频，今天写了人生中得第一个脚本，虽然是一个很简单得不能再简单得脚本，可它也是个脚本，希望自己继续保持学习，再接再励，不要放弃</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基础课-基础算法</title>
      <link href="/2023/12/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE(1)/"/>
      <url>/2023/12/26/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序模板"><a href="#快速排序模板" class="headerlink" title="快速排序模板"></a>快速排序模板</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> q[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&gt;=r)  <span class="hljs-keyword">return</span>;    <span class="hljs-type">int</span> i=l<span class="hljs-number">-1</span>,j=r+<span class="hljs-number">1</span>, x=q[l+r&gt;&gt;<span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i&lt;j)    &#123;        <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i]&lt;x);        <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j]&gt;x);        <span class="hljs-keyword">if</span>(i&lt;j) <span class="hljs-built_in">swap</span>(q[i],q[j]);    &#125;    <span class="hljs-built_in">quick_sort</span>(q,l,j);    <span class="hljs-built_in">quick_sort</span>(q,j+<span class="hljs-number">1</span>,r);    &#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-built_in">quick_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><h3 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h3><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1000010</span>;<span class="hljs-type">int</span> q[N],temp[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//递归的终止情况</span>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//第一步：分成子问题</span>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;    <span class="hljs-comment">//第二步：递归处理子问题</span>    <span class="hljs-built_in">merge_sort</span>(q, l, mid ), <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);    <span class="hljs-comment">//第三步：合并子问题</span>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>, tmp[r - l + <span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];        <span class="hljs-keyword">else</span> tmp[k++] = q[j++];    <span class="hljs-keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];    <span class="hljs-keyword">while</span>(j &lt;= r) tmp[k++] = q[j++];    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>, i = l; i &lt;= r; k++, i++) q[i] = tmp[k];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-built_in">merge_sort</span>(q,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,q[j]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h3><pre><code class="hljs C++"><span class="hljs-comment">//写的 非常好的二分模板</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">5</span>;<span class="hljs-type">int</span> n,m,q[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q[i]);    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> k;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);        <span class="hljs-comment">//寻找第一个等于K的坐标 我这边让二分的边界定为 左边为&lt;5 右边&gt;=5 则所求为r</span>        <span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=n;        <span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>!=r)<span class="hljs-comment">//当l与r没有相接的时候,求边界</span>        &#123;            <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;            <span class="hljs-comment">//下面找第一个&gt;=5的坐标</span>            <span class="hljs-keyword">if</span>(q[mid]&gt;=k) r=mid;            <span class="hljs-keyword">else</span> l=mid;        &#125;        <span class="hljs-comment">//此时得到的r是第一个&gt;=5的坐标</span>        <span class="hljs-keyword">if</span>(q[r]!=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1 -1\n&quot;</span>);        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,r);                <span class="hljs-comment">//现在找最后一个&lt;=5的数字 我这边让二分的左边为&lt;=5 右边为&gt;5 则所求为ll</span>                <span class="hljs-type">int</span> ll=<span class="hljs-number">-1</span>,rr=n;                <span class="hljs-keyword">while</span>(ll+<span class="hljs-number">1</span>!=rr)                &#123;                                        <span class="hljs-type">int</span> mid=ll+rr&gt;&gt;<span class="hljs-number">1</span>;                    <span class="hljs-keyword">if</span>(q[mid]&lt;=k) ll=mid;                    <span class="hljs-keyword">else</span> rr=mid;                &#125;                <span class="hljs-keyword">if</span>(q[ll]!=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,r);                <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ll);            &#125;            &#125;    &#125;<span class="hljs-comment">//非常好的二分博客引用</span>https:<span class="hljs-comment">//blog.csdn.net/WJPnb1/article/details/126360962?spm=1001.2014.3001.5502</span></code></pre><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法模板"><a href="#高精度加法模板" class="headerlink" title="高精度加法模板"></a>高精度加法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//总结：</span><span class="hljs-comment">//第一步：字符串输入</span><span class="hljs-comment">//第二步：字符串转数字，逆序</span><span class="hljs-comment">//第三步：模板相加；</span><span class="hljs-comment">//第四步：逆序输出</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><span class="hljs-function"></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; C;    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);        t/=<span class="hljs-number">10</span>;    &#125;    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string a,b;    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//123456</span>    vector&lt;<span class="hljs-type">int</span>&gt;A,B;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//[6,5,4,3,2,1]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">auto</span> C=<span class="hljs-built_in">add</span>(A,B);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="高精度减法模板"><a href="#高精度减法模板" class="headerlink" title="高精度减法模板"></a>高精度减法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//第一步：输入</span><span class="hljs-comment">//第二步：比较</span><span class="hljs-comment">//第三步：相减：注意括号和前缀0要去掉</span><span class="hljs-comment">//第四步：输出</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)             <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;A,vector&lt;<span class="hljs-type">int</span>&gt;&amp;B)</span></span><span class="hljs-function"></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt;C;    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)    &#123;        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t=A[i]-t;        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t-=B[i];        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//虽然A比B大，但是A的某一位的数字可能比B小，所以这里加上10再模10</span>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t=<span class="hljs-number">1</span>;<span class="hljs-comment">//用于给A去减掉</span>        <span class="hljs-keyword">else</span> t=<span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    string a,b;    vector&lt;<span class="hljs-type">int</span>&gt; A,B;    cin&gt;&gt;a&gt;&gt;b;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i]-<span class="hljs-string">&#x27;0&#x27;</span>);    vector&lt;<span class="hljs-type">int</span>&gt;C;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B)) C=<span class="hljs-built_in">sub</span>(A,B);    <span class="hljs-keyword">else</span> C=<span class="hljs-built_in">sub</span>(B,A),cout &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<span class="hljs-comment">//这里的负号是A-B=-(B-A)；</span>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);    cout&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;</code></pre><h4 id="高精度乘法模板"><a href="#高精度乘法模板" class="headerlink" title="高精度乘法模板"></a>高精度乘法模板</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span> </span>&#123;    <span class="hljs-comment">// A: 4 3 2 1</span>    <span class="hljs-comment">// B: 6 5</span>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(max(A.size(), B.size()) + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 数组C开大一点没事，反正可以去前导零的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) C[i] += A[i];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; B.<span class="hljs-built_in">size</span>(); i ++) C[i] += B[i];    <span class="hljs-comment">// 处理进位</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; C.<span class="hljs-built_in">size</span>(); i ++) &#123;        C[i + <span class="hljs-number">1</span>] += C[i] / <span class="hljs-number">10</span>;        C[i] %= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-comment">// 处理前导零</span>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; A, vector&lt;<span class="hljs-type">int</span>&gt; B)</span> </span>&#123;    <span class="hljs-comment">// A: 4 3 2 1</span>    <span class="hljs-comment">// B: 6 5</span>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">C</span><span class="hljs-params">(A.size() + B.size() + <span class="hljs-number">7</span>, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">// 数组C开大一点没事，反正可以去前导零的</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; B.<span class="hljs-built_in">size</span>(); j ++) &#123;            C[i + j] += A[i] * B[j];        &#125;    &#125;    <span class="hljs-comment">// 处理进位</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; C.<span class="hljs-built_in">size</span>(); i ++) &#123;        C[i + <span class="hljs-number">1</span>] += C[i] / <span class="hljs-number">10</span>;        C[i] %= <span class="hljs-number">10</span>;    &#125;    <span class="hljs-comment">// 处理前导零 &quot;0000&quot; 去掉前导零</span>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    string s1 = <span class="hljs-string">&quot;9899&quot;</span>, s2 = <span class="hljs-string">&quot;100&quot;</span>;    vector&lt;<span class="hljs-type">int</span>&gt; A, B;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) A.<span class="hljs-built_in">push_back</span>(s1[i] - <span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) B.<span class="hljs-built_in">push_back</span>(s2[i] - <span class="hljs-string">&#x27;0&#x27;</span>);    vector&lt;<span class="hljs-type">int</span>&gt; C = <span class="hljs-built_in">add</span>(A, B);    cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;=&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i ++) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    C = <span class="hljs-built_in">mul</span>(A, B);    cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot;*&quot;</span> &lt;&lt; s2 &lt;&lt; <span class="hljs-string">&quot;=&quot;</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; C.<span class="hljs-built_in">size</span>(); i ++) cout &lt;&lt; C[i];    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;链接：https:<span class="hljs-comment">//www.acwing.com/solution/content/13694/</span></code></pre><h4 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h4><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-comment">//int r=0;</span><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> B,<span class="hljs-type">int</span> &amp;r)</span></span>&#123;<span class="hljs-comment">//r传入r的地址，便于直接对余数r进行修改</span>    vector&lt;<span class="hljs-type">int</span>&gt; C;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>();i++)&#123;<span class="hljs-comment">//对A从最高位开始处理</span>        r=r*<span class="hljs-number">10</span>+A[i];<span class="hljs-comment">//将上次的余数*10在加上当前位的数字，便是该位需要除的被除数</span>        C.<span class="hljs-built_in">push_back</span>(r/B);<span class="hljs-comment">//所得即为商在这一位的数字</span>        r=r%B;<span class="hljs-comment">//这里的余数是一个等价关系，不懂可以看视频</span>    &#125;    <span class="hljs-comment">//由于在除法运算中，高位到低位运算，因此C的前导零都在vector的前面而不是尾部，vector只有删除最后一个数字pop_back是常数复杂度，而对于删除第一位没有相应的库函数可以使用，而且删除第一位，其余位也要前移，</span>    <span class="hljs-comment">//因此我们将C翻转，这样0就位于数组尾部，可以使用pop函数删除前导0</span>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()==<span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();    <span class="hljs-keyword">return</span> C;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    string a;    <span class="hljs-type">int</span> B,r=<span class="hljs-number">0</span>; <span class="hljs-comment">//代表余数</span>    cin&gt;&gt;a&gt;&gt;B;    vector&lt;<span class="hljs-type">int</span>&gt; A;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.<span class="hljs-built_in">size</span>();i++) A.<span class="hljs-built_in">push_back</span>(a[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//注意这次的A是由高为传输至低位，由于在除法的手算过程中，发现从高位进行处理</span>    <span class="hljs-comment">//for(int i=0;i&lt;A.size();i++) cout&lt;&lt;A[i];</span>    <span class="hljs-comment">//cout&lt;&lt;B;</span>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A,B,r);    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) cout&lt;&lt;C[i];<span class="hljs-comment">//将C从最高位传给最低位</span>    cout&lt;&lt;endl&lt;&lt;r;<span class="hljs-comment">//输出余数</span>    cout&lt;&lt;endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><pre><code class="hljs C++"><span class="hljs-comment">//前缀和的思想是存sum，然后相减进行计算</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<span class="hljs-type">int</span> a[N],sum[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m,x;    cin&gt;&gt;n&gt;&gt;m;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)    &#123;        cin&gt;&gt;x;        sum[i]=x+sum[i<span class="hljs-number">-1</span>];    &#125;    <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> l,r;        cin&gt;&gt;l&gt;&gt;r;        cout&lt;&lt;sum[r]-sum[l<span class="hljs-number">-1</span>]&lt;&lt;endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="一维差分模板"><a href="#一维差分模板" class="headerlink" title="一维差分模板"></a>一维差分模板</h4><pre><code class="hljs C++"><span class="hljs-comment">//差分非常高效的减少了运算关系的时间复杂度，二维差分的模板同样可以看y总给的那个矩阵</span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> a[N],b[N];<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;l,<span class="hljs-type">int</span> &amp;r,<span class="hljs-type">int</span> &amp;c)</span></span><span class="hljs-function"></span>&#123;    b[l]+=c;    b[r+<span class="hljs-number">1</span>]-=c;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n,m;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">insert</span>(i,i,a[i]);        <span class="hljs-keyword">while</span>(m--)    &#123;        <span class="hljs-type">int</span> l,r,c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r,&amp;c);        <span class="hljs-built_in">insert</span>(l,r,c);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i ++ ) b[i]+=b[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;=n; i ++ ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,b[i]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h3><h4 id="最长连续不重复子序列"><a href="#最长连续不重复子序列" class="headerlink" title="最长连续不重复子序列"></a>最长连续不重复子序列</h4><pre><code class="hljs C++"><span class="hljs-comment">//其实这在后面好像是一道dp题目，双指针算法的核心就是用两个指针来解题</span><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<span class="hljs-type">int</span> a[N], s[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n, r = <span class="hljs-number">0</span>;    cin &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; ++ i)    &#123;        cin &gt;&gt; a[i];        ++ s[a[i]];        <span class="hljs-keyword">while</span> (s[a[i]] &gt; <span class="hljs-number">1</span>) -- s[a[j++]]; <span class="hljs-comment">// 先减次数后右移</span>        r = <span class="hljs-built_in">max</span>(r, i - j + <span class="hljs-number">1</span>) ;    &#125;    cout &lt;&lt; r;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code class="hljs `C++">//这里主要是了解一个lowbit操作#include&lt;bits/stdc++.h&gt;using namespace std;int  lowbit(int &amp;x)//这个代码的关键是这个函数，每次输出x=的最后一位1;&#123;    return x&amp;-x;&#125;int main()&#123;    int n;    cin&gt;&gt;n;    while (n -- )    &#123;        int x;         cin &gt;&gt; x;        int res=0;        while(x&gt;0) x-=lowbit(x),res++;//每次减去x的最后一位1;直到没有1，那么res即为所求        cout &lt;&lt; res&lt;&lt;&quot; &quot;;    &#125;    &#125;</code></pre><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><pre><code class="hljs C++"><span class="hljs-comment">//当空间稀疏性非常大的时候的做法，最后的实现也是前缀和，通过离散化，将空间的利用率降低了</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300010</span>; <span class="hljs-comment">//n次插入和m次查询相关数据量的上界</span><span class="hljs-type">int</span> n, m;<span class="hljs-type">int</span> a[N];<span class="hljs-comment">//存储坐标插入的值</span><span class="hljs-type">int</span> s[N];<span class="hljs-comment">//存储数组a的前缀和</span>vector&lt;<span class="hljs-type">int</span>&gt; alls;  <span class="hljs-comment">//存储（所有与插入和查询有关的）坐标</span>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; add, query; <span class="hljs-comment">//存储插入和询问操作的数据</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-comment">//返回的是输入的坐标的离散化下标</span>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (l &lt; r) &#123;        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-type">int</span> x, c;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;x, &amp;c);        add.<span class="hljs-built_in">push_back</span>(&#123;x, c&#125;);        alls.<span class="hljs-built_in">push_back</span>(x);    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;        <span class="hljs-type">int</span> l , r;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);        query.<span class="hljs-built_in">push_back</span>(&#123;l, r&#125;);        alls.<span class="hljs-built_in">push_back</span>(l);        alls.<span class="hljs-built_in">push_back</span>(r);    &#125;   <span class="hljs-comment">//排序，去重</span>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>());    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());    <span class="hljs-comment">//执行前n次插入操作</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : add) &#123;        <span class="hljs-type">int</span> x = <span class="hljs-built_in">find</span>(item.first);        a[x] += item.second;    &#125;    <span class="hljs-comment">//前缀和</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= alls.<span class="hljs-built_in">size</span>(); i++) s[i] = s[i<span class="hljs-number">-1</span>] + a[i];    <span class="hljs-comment">//处理后m次询问操作</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : query) &#123;        <span class="hljs-type">int</span> l = <span class="hljs-built_in">find</span>(item.first);        <span class="hljs-type">int</span> r = <span class="hljs-built_in">find</span>(item.second);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, s[r] - s[l<span class="hljs-number">-1</span>]);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h3><pre><code class="hljs C++">这里看到一个区间合并，很绝的思路模板<span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; PII;PII a[N];<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-type">int</span> n;    cin&gt;&gt;n;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);    <span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-comment">//sort对于二元组的排序规则是先考虑第一个元素，再考虑第二个元素</span>    <span class="hljs-type">int</span> ed=a[<span class="hljs-number">1</span>].second,ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)    &#123;        <span class="hljs-keyword">if</span>(ed&gt;=a[i].first)ed=<span class="hljs-built_in">max</span>(ed,a[i].second);        <span class="hljs-keyword">else</span> ans++,ed=a[i].second;    &#125;    cout&lt;&lt;ans+<span class="hljs-number">1</span>&lt;&lt;endl;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础课-1</title>
      <link href="/2023/12/25/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE-1/"/>
      <url>/2023/12/25/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>新思科技EDA软件开发要求</title>
      <link href="/2023/12/18/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/"/>
      <url>/2023/12/18/%E5%B7%A5%E4%BD%9C%E5%B2%97%E4%BD%8D%E8%A6%81%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>这里他提到了多种语言，说明他对语言的要求是很高的，所以需要抓紧时间熟悉语言并熟练运用</p><p>职位描述:</p><p>平台验证工程师负责验证业界领先的SOC实现工具和流程解决方案，如“IC Compiler II”，“Design Compiler”，formal和下一代数字平台“Fusion Compiler”等。</p><p>·了解客户需求，基于数字化设计流程验证新特性，包括先进节点、5nm、3nm等新特性。</p><p>·验证Synopsys前端/后端流程，跟踪前端/后端流程QOR/性能。</p><p>·了解客户使用情况，提出新要求，完善流程解决方案。</p><p>·用Perl、TCL、Python或C/ c++设计和开发测试程序，包括测试工具和自动化测试套件。</p><p>工作要求:</p><p>电子电气、微电子或相关专业硕士，三年工作经验</p><p>·精通ASIC设计流程。包括平面图，综合，P&amp;R, STA等。期望在很少的复习和指导下找出问题的经典解决方案</p><p>·具有团队合作精神和良好的学习能力，对先进技术和设计流程方法论保持热情和兴趣!</p><p>·必须具备较强的沟通和人际交往能力</p><p>·具备良好的中英文口头和书面沟通能力</p><p>·具有以下一个或多个计算机科学领域的知识和经验者优先考虑:</p><p>编程语言(C/ c++， Shell, TCL, Perl, Python等)</p><p>·Unix/Linux操作系统</p>]]></content>
      
      
      <categories>
          
          <category> 找工作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记-11-20</title>
      <link href="/2023/11/20/%E6%97%A5%E8%AE%B011-20/"/>
      <url>/2023/11/20/%E6%97%A5%E8%AE%B011-20/</url>
      
        <content type="html"><![CDATA[<h2 id="随想"><a href="#随想" class="headerlink" title="随想"></a>随想</h2><p>应该很久没有写日记了，已经忘记上次写日记是哪天了，生活似乎并没有好过点，还是在不断的告诉自己熬过去熬过去中一天天度过，不知道生活什么时候才会有变化，也许我应该时常问自己，邓福星，你有慢慢的变成更好的自己的吗，不知道为什么，我想告诉自己，我确实好像似乎，在慢慢的变好，我的体重慢慢的下去，我慢慢的去护肤，慢慢的健身，慢慢的去体会生活，我想比起之前的一团糟，我觉得我确实有在慢慢变好，我还是有些时候免不了想陶俊余，我在想，是不是每当我脆弱的时候，我就会想有复合的念头，这样的念头是不正确的，也不该有的对吗，我应该习惯自己慢慢的面对这一切，就写到这里吧，得去忙着改代码了</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于时光朋友的反思</title>
      <link href="/2023/10/22/%E9%9A%8F%E6%83%B310-22/"/>
      <url>/2023/10/22/%E9%9A%8F%E6%83%B310-22/</url>
      
        <content type="html"><![CDATA[<p>今晚不知道为什么，对于朋友，有很多很多的感触，我觉得应该都要好好珍惜，人生在世，认识谁都特别不容易，我们要尊重并祝福每个人，每个身边人，少点戾气，多点包容和宽容，珍惜正在发生和将要发生的一起，邓福星，要脾气好点哦</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于论文的反思</title>
      <link href="/2023/10/19/%E9%9A%8F%E6%83%B310-19/"/>
      <url>/2023/10/19/%E9%9A%8F%E6%83%B310-19/</url>
      
        <content type="html"><![CDATA[<p>时间过得真快，上一次写文章还是半个月之前了，今天写文章是因为一件事情，也就是跟随师姐们写论文的事情，这件事情让我有些困扰，今天吃饭的时候，一航问我，为什么最近李靖不找我了，其实我想，李靖不找我已经很久了，写这篇文章是想总结一下我心里的想法，就是，我希望李靖找我吗，如果她找了我，并且我认真且热情的回应了她，并且很沉浸进去的和她一起写论文，我想也许我能得到一个论文的二作，并且也许有可能接手李靖的课题，我想我此刻惋惜的也许也是这个，看着大家都有了不错的成绩，都有机会发论文带上名字，我想我心里是很羡慕的，又或者说，我嫉妒?，其实内心里有一点点涉及父母，我不知道我为什么会涉及到父母，也许发篇论文是一件很关键的事情。也许我希望他们的儿子有所成就，也许我心里也想不落后于别人，我想问邓福星，你很想要这个论文作者吗，我想答案是No,没有很想，只是不希望落后与别人，那我要去争取吗，我想我不想去争取，对我来说，这些事情，我看的并不是很重要，至少现在是这样的，我要为了将来的事情去提前做准备吗，为了将来读博的可能性去再争取一下吗，我想不是的，我不想去，是的，我不想去。也许李靖师姐已经很主动了，她对我应该有些失望，但是我不想，是的，我觉得我心力交瘁，我也不知道我追求什么，但我知道的是，我并不是很想再重新参与进去了，我衷心祝愿每个同门有个好结果，可我不应该去进行比较了，我只要过好自己的生活，过好自己的每一天就好了，以后的时间很长，我不去想以后的事，我也不关心别人的想法，我要照顾好我自己，好好的对待我自己，什么狗屁学术，什么狗屁追求，命定的一切终有安排，一切都是外物，把自己过好就可以了。把自己过好就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记-10-2</title>
      <link href="/2023/10/02/%E6%97%A5%E8%AE%B010.2/"/>
      <url>/2023/10/02/%E6%97%A5%E8%AE%B010.2/</url>
      
        <content type="html"><![CDATA[<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>心里有一件比较不舒服的事情，想写下来，并且刨析我自己，今天是校庆70周年，学校是提供免费午餐的，之前是去登记过了，但是今天去吃饭的时候，阿姨问我有没有餐券我才想起来，我就说今天好多人在三食堂吃饭，于是这段饭我花了20多块，让我本就不富裕的生活学上加霜，我心里开始责怪戴闻浩，我责怪他没有通知我去哪里领餐券，并且为自己没有赚到学校的这个便宜而不开心，心中始终觉得不快，所以我决定对这件事情进行复盘</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>  事件真的是戴闻浩的错吗，学校传达了通知他没有及时告知吗，又或者也许学校没有传达，我想我不该责怪，但我可以问一下，当然，只是询问而已，第二个，当时在阿姨问我有没有餐券的时候，我想我是可以当时去问餐券这个事情，但是我是吃饭的时候才想起来之前登记了免费的午餐，在付钱的时候，我的选择是不进行探究，付了这笔钱，我想是因为我发现我点的餐达到了21.5，所以我心里才不开心吧，所以这是我自己犯的错误，我有机会补救，但我没有，是我自己选择了付钱，不能把问题推到别人身上，也许，我是推卸自己的责任罢了，是的，一切事情都不能指望别人事事靠谱，也不能因为别人没有完善职责，而让自己心里不快，因为事件上什么事情都是可能发生的，愤怒不是合理的，甚至于他不该存在，又或者说，他不该轻易发生，刚闻浩回了微信，说是他这里还有餐券，我想这件事情他也有通知不到位的地方吧，嗯，我觉得这件事情，大部分都是他的问题，他没有履行到他的职责，因为学校方面把这件事情交给了班长。也就是说，即使我当时犹豫了，在付钱之前去问他餐券的事情，我也需要跑去主楼B410问他，对我来说，我可能宁愿花点钱买饭，毕竟也是我自己吃的，算不上冤枉钱。没有必要为这种事情责怪自己，或者感觉心里不痛快，人不患穷，患不均是这样的。人生值得关注的事情真的很少，要关注每一个瞬间，这件事情是一件很小的事情啦，需要修行的地方还很多，所以不要在为这种小事情困扰自己，错误已经造成，又或者说失误已经造成，就没有必要花很多时间去追求失误，去追究责任，尤其是，你没有足够的能力，结果只能是浪费时间而且内耗。但是你可以更清楚地认识一个人是什么样的，了解一个人的做事风格是什么样的，知道一个人靠不靠谱，这样将来可以避免更大的错误，做一个不评论的观察者，是一个很需要智慧的事情</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记-9-16</title>
      <link href="/2023/09/16/%E6%97%A5%E8%AE%B09.16/"/>
      <url>/2023/09/16/%E6%97%A5%E8%AE%B09.16/</url>
      
        <content type="html"><![CDATA[<p>最近很久没写日记了，也是因为最近在伤愈之中，只从小号被一句话不留的删掉之后，好不容易缝起来的自己，好像啪的一下又碎掉了，今天写日记主要是为了纪念一个小小的感动，也浅浅描述一下最近发生的事情</p><h2 id="感动"><a href="#感动" class="headerlink" title="感动"></a>感动</h2><p>因为上课的路途很远的问题，宿舍里只有我一个人是走路去，其实我觉得没什么，张津豪，我的室友，是一个很机灵也很善于打探消息的一个人，学校每年都会收捡毕业生遗留未带走的单车，然后收集起来，通过一个考试，按成绩排名，发放给学生，我的室友，他已经有一部单车了，他还专门去考试，它拿到了，而我排名落后没有拿到，结果今晚他说，明天领车了，要把那部车送给我，因为我没有车，唉，着实有点感动，挺谢谢的吧</p><h2 id="琐事"><a href="#琐事" class="headerlink" title="琐事"></a>琐事</h2><p>最近申请了贫困补助，是b类，就是家庭困难级别，不知道有没有钱，有多少钱</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>告别语</title>
      <link href="/2023/08/29/%E5%91%8A%E5%88%AB%E8%AF%AD/"/>
      <url>/2023/08/29/%E5%91%8A%E5%88%AB%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>还是想好好告个别，源于我五年前听的两个小故事，我原封不动的搬回来</p><h1 id="故事一"><a href="#故事一" class="headerlink" title="故事一"></a>故事一</h1><p>大家晚上好，这里是就服秘书处深夜电台第三期，还是我杨杨。<br>时间好快，这一年对于一八级的孩子们而言，经历了太多太多。上半年的大家还在高中为高考而殚精竭虑，下半年迢迢而至来到雅西川农。或许，你们很多人只是之身而来，把太多太多留在了过去。今晚，杨杨给大家带来的是一个故事。虽不扣人心弦，但是值得我们每一个人去思考，去感受。这个故事的名字叫做《章台柳》。<br>唐朝玄宗皇帝年间，有一个才子叫作韩翊（yi第四声）。韩翊年少有才考中进士，回乡省亲时与同乡佳人柳氏结为连理，二人情投意合相爱至深。不久，韩翊走马上任，需要背井离乡去淄青节度使账下做官。路途遥远且官资尚浅，韩翊不便带上爱妻，只能让柳氏独守家中相约日后夫君锦衣归来。<br>可是，韩翊上任不久后，安史之乱爆发。叛军气势汹汹占领了大片城池，其中就包括韩翊的家乡。柳氏没能等到韩翊的归来，只能自己东躲西藏。因为柳氏姿容美艳而又没有丈夫在身边保护，乱世之中总被人骚扰。她怕自己的美艳惹祸哪天被人玷污，不能还韩翊玉洁之身，便剪断一头乌发，自毁容颜，躲避于僻静的山寺之中，晨钟暮鼓，只盼夫君韩翊早日到来。<br>后来，安史之乱平息。韩翊官升数级，进入朝堂。他派人回乡打听妻子柳氏的下落。这时的韩翊却生了鸡肠之心。他写了一封信给手下带回家乡寻柳氏。心里写道“章台柳，章台柳，昔日青青今在否？纵使长条似旧垂，亦应攀折他人手。”意思很明了，韩翊质问柳氏，你如此美貌又过了那么多年，肯定攀附别人去了。<br>手下带着这封信回到了韩翊故乡，找到了妻子柳氏。柳氏看完韩翊的信后心灰意冷，可怜自己为他做的一切。柳氏回信给韩翊，信里写道“杨柳枝，芳菲节。所很年年赠离别，一叶随风忽报秋，纵使君来不堪折。”意思别是，自己纵然是一颗婀娜的杨柳，但是如今也是秋过枯黄，即便是你回来也不愿再回顾这棵曾经的柳了。柳氏不诉说自己的委屈，只是对韩翊死心了。<br>可这封书信还没能送到韩翊手中。外番将军沙吒利路过韩翊家乡看到了柳氏，大为心动，便把柳氏抢占为己有。柳氏便这样被沙吒利带回了长安，沙吒利对柳氏还算好，柳氏也成了将军的宠妾。可这事传到了同样在长安的韩翊耳中，韩翊大为震惊。一天宴席中韩翊的好友发觉韩翊心事重重便询问他。韩翊把柳氏的事情告诉了好友，好友听后决心替韩翊抢回柳氏。于是立刻骑马跑到沙吒利府上，正好沙将军外出，他便以沙吒利遇害将死想见柳氏最后一眼为理由接到了柳氏，马上把柳氏带到韩翊府中。韩柳二人终得相逢，柳氏把这些年来自己的遭遇一一告诉了韩翊，韩翊自责不已。后来，韩翊在自己老上级的帮助下从沙吒利手中赎回来柳氏，一对苦命鸳鸯终得重逢。从此过上了幸福快乐的生活。<br>每个故事都有属于读者自己的领会，希望大家能在这个深夜静静地看完故事，日后不要负了你的章台柳。</p><h1 id="故事二"><a href="#故事二" class="headerlink" title="故事二"></a>故事二</h1><p>大概是五六年前，也是在川农，有一对师兄师姐，他们高中就是同学，后来不约而同地上了川农，可能是他乡遇故知的亲切感使然吧，他们大一就耍朋友了，这段情感绵绵到了大四，俩人都选择了考研互相鼓励，而且俩人成绩都不错，以前做了很多实践科研什么的，简直一对璧人。五六年前的那次考研结束后，可能是此间真情天也妒吧。师兄上了川大的研究生，师姐经过调剂又复试后没过，上不了研。可能是师姐家庭条件的原因她不能选择二战，于是师姐选择了回去家乡考公务员。此时二人许诺四年了，这段情不会因为三年的殊途而变故。毕业后的那个暑假他们一起去了西藏，看了圣洁的布达拉宫，一起走了文成公主曾经来过的路。<br>后来开学了，师兄去了川大。师姐回了他们的家乡备考公务员。每天都会相互问候，每周末师兄都会回家见面。这一年师姐考上了家乡的公务员，做了一个区政府的科员。研二以后师兄越来越忙，因为专业的需要师兄和导师去了云南西双版纳，师兄忙碌的科研生活无法再抽时间和师姐通讯交流。这时的师姐被家里人催婚了，因为师姐有稳定工作稳定收入，父母担心就是成家了。师姐告诉父母她和师兄有约，师兄毕业后他们才谈婚论嫁。尽管这时候师兄师姐已经大半年没好好联系了。<br>那一年师兄研三，在准备毕业了。那一年师姐结婚了，新郎是师姐区政府的同事，这三年来一直在单位体贴照顾师姐的一个好男人。<br>师兄川大硕士研究生毕业后没有再去找师姐也没有回家，而是去以色列进修了。曾经的一对璧人，五六年后，造物告诉他们，青春很美，因为那是一副画，也是一场梦。</p><p>但是现在的他们都很幸福，师兄在进步，师姐也有了好归属。就是这么看都觉得有点遗憾</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记 8-27</title>
      <link href="/2023/08/27/%E6%97%A5%E8%AE%B08-27/"/>
      <url>/2023/08/27/%E6%97%A5%E8%AE%B08-27/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天想了一些乱七八糟的，不切实际的，大概就是陶俊余也想找我复合吧，但有什么迫不得已的原因，仔细想想，白日做梦罢了，总是有这些不切实际的幻想，对了，来学校一周了，每天的内裤和袜子都每天洗，虽然有什么很累，但还是爬起来洗了，好想告诉他，我正在慢慢的该这些坏习惯，也很久没说他妈的了，唉，可惜再也回不去了</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天主打就是一个摆烂，什么也没做，难得没有什么事，休息了一天</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>没什么反思，适当的摆烂是必要的。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-8-26</title>
      <link href="/2023/08/26/%E6%97%A5%E8%AE%B08-26/"/>
      <url>/2023/08/26/%E6%97%A5%E8%AE%B08-26/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天中午想到了一些事情，自己也感同深受了一番，觉得过去对陶俊余说过的很多话都带有指责逼问的意思，虽然那个时候我自己并没有意识到，或者意识到了，但是面对陶俊余的妥协和忍让，让我觉得这不是什么大不了的事情，一直没有重视这个问题，以至于长期以来甚至对她说的不要骂我，以及害怕我感到很不解，但是今天我终于懂了，因为我自己也经历了一番，觉得真的是一件很委屈很委屈的事情，一想到过去自己对陶俊余那么不好，情绪又崩溃了，一直哭一直哭，中午在路上的时候忍住眼泪没掉下来，回来宿舍之后，躺在床上忍不住的嚎啕大哭，把眼睛都哭肿了，现在哭的眼睛还疼，很想给她发消息说对不起什么的，但是我想现在好像正是秋招的关键时期，不要打扰她的比较好，我所能为她做的，最大的事情，大概就是不打扰她吧，真心希望她能找到一个好男人，不要再碰到我这种垃圾了，真心真心希望她幸福，其实我才是那个最自我的人</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天戴闻浩的语气让我很不爽，以后跟这人少接触吧，戾气太重了，今天是摆烂的一天，什么事情也做不进去</p><h1 id="今日反思"><a href="#今日反思" class="headerlink" title="今日反思"></a>今日反思</h1><p>以后如果生气了想说什么话，一定不要说，要忍者，因为通常你生气的时候说出的话，事后你会觉得很后悔</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-8-25</title>
      <link href="/2023/08/25/%E6%97%A5%E8%AE%B08-25/"/>
      <url>/2023/08/25/%E6%97%A5%E8%AE%B08-25/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天发现原来今天才8月25号，20号给陶俊余发消息没有回复以后，每一天都过得很艰难也很漫长，让我以为时间已经过去了很久，原来也才5天，对于感情的想法是，也许我不值得拥有感情，也不该再去耽误别人，我想我是一个很差劲的人</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>今天早上是开学典礼，开了一会我就走了，后来去了图书馆，因为暑假的作业一直没写，老师又一直催，所以去图书管写作业，但是那个代码对我来说太难了，今天一天把我头都给想大了，大脑实在是不能继续运转，下午四点多的时候，实在是精神不能再聚焦，于是我回宿舍，爬到床上，很快的睡了一个多小时，工科读研感觉真的挺难的，中午吃饭和师兄聊天，才知道原来就业形势并没有那么好，真正的了解到了什么是大饼，但是我本就一开始就没有选择，今后要抓紧自学，把时间都利用起来，我想三年，应该最后能找个还行的工作，一定要努力学习，把时间把握在自己的手中，睡完觉之后就去图书馆看了会代码，很快就写出来了，成功的原因在于下午睡觉之前和朋友交流了一下，所以说交流时很有必要的，向成功的人交流</p><h1 id="今日反思"><a href="#今日反思" class="headerlink" title="今日反思"></a>今日反思</h1><p>今天才又一次意识到应该抓紧时间自学，一丁点时间也不能再继续浪费了，为了找个好工作，不要再重蹈本科的覆辙了。收获在于知道了如果你很累，那就去休息，但不是玩手机，休息完之后也许一切就茅塞顿开了，最近博客上传照片总是失败，找个时间研究一下，最近太忙了</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-8-24</title>
      <link href="/2023/08/24/%E6%97%A5%E8%AE%B08-24/"/>
      <url>/2023/08/24/%E6%97%A5%E8%AE%B08-24/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>昨天没有写日记，其实昨天想写的东西还挺多的，那一会懒得开电脑了所以没有记录，今天把还记得得一起写下来，昨天导师让我们去城里参加一个会，risc-v中国区峰会。本来报名时间都过了，因为导师是汇报人员，也就是大佬，没报名也让我们去了，但其实大家是不想去得，峰会在北京香格里拉饭店，在城里，坐地铁要一个多小时，但是导师说要一起拍照合照，于是我们六点起床，我和另外四个同学打了一个六座得商务座去了北京，每人60，宿舍有一个叫段永强得，已经几天没回宿舍睡了，他的女朋友为了他。来昌平找工作了，他们在昌平租了个房子，我问了下价格800，说实话我很羡慕他们那个时候，但是我忘记了我羡慕得是啥了，但那一刻我心里满是陶俊余，这就是昨天得情感故事了，今天我突然想起，我和她第一次分手得时候，我问她还我2000块钱，还发短信骂她，这真的是一件非常过分得事情呀，可是我直到今天才意识到这件事情真的很过分，我想也许我才是一个自我的人，我沉浸在自我的世界和忙于保护自我，其实她早已被我伤害得体无完肤，我那样得过分，她还愿意和我复合，我想其实她是想和我走下去得，至少曾经是这样的，我时常害怕自己是唯一一个还困在原地得人，可我不得不去面对我心里得很多很多得放不下得事情和突然涌上得回忆，我还对她有诸多得欺骗和隐瞒，她以前说的没错，她确实是一个吸渣体制，谈的都是渣男，今天晚上坐在图书馆刷抖音得时候，刷到重庆火锅一度还落下泪来，觉得其实自己也受了好多委屈，去成都两个月其实也没吃啥好的，连自己很喜欢吃的烧烤一次都没去吃过，只在那个巷子门口那个烧烤摊吃过，最后一次想好好吃个烧烤，结果因为说错话，在大庭广众之下被吼，最后也没好好吃，其实觉得自己也受了挺多委屈得，到了成都疯狂得找工作，试工作，每天两个小时得通勤，其实也没过什么好日子，如果不是为了爱情，我在家里怎么需要受这样得苦，唉，现在回想起来觉得自己挺矫情得，和我分手是对的，分手之后，其实我一直陷入一种自我怀疑当中，觉得自己很差劲很差劲，现在想着确实很差劲很差劲，简直就是垃圾，毒瘤，离开我是对的，我这种人不值得留恋</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>生活今天早上开研究生新生教育会，下去去实验室和师姐讨论课题，实验室太闷了，我实在呆不下去，转战到图书馆，今天一点学习得心情都没有，头晕呼呼得，不想动脑子，在图书馆一直刷抖音吃播，好像就是这么平平无奇得一天</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-8-20</title>
      <link href="/2023/08/22/%E6%97%A5%E8%AE%B08-22/"/>
      <url>/2023/08/22/%E6%97%A5%E8%AE%B08-22/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天是七夕，难得看见陶俊余的qq头像和背景换了，大意就是搞钱的意思吧，早上还是想起陶俊余，想起我对她做过的那些过分的事情，我想她一定受了很多委屈吧，我想道歉想弥补，可这些事情已经没有什么意义了，一切都没有意义了，她那一跪在我眼前，我想起内心就害怕，甚至不敢回想，可我不得不面对，那是我这一生都无法原谅自己的事情，还有她在门外敲门，回想起来，我怎么能做出这些事情呢，那些事情回想起来都不像我自己，可那就是我自己，虽然没没回想起来这些事情，已经没机会弥补，甚至即使有机会弥补，也可能只是越做越差，甚至带来更大的伤害，可我还是忍不住的回想，忍不住的想道歉。遇见我对她来说，是一种不幸吧，我怎么会是那样的一个人呢，也许我本身就是一个很坏的人吧，希望她能找到一个很好的人，不要再遇到我这种垃圾，我只会说这种话了</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>今早醒来的时候已经七点多了，洗脸刷牙收拾后，去外面散步四公里，去图书馆的时候已经快接近十点了，十一点多的时候，师兄通知十二点开组会，开组会的时候，导师和师兄都带饭，边带边开，听说是刘院长从欧洲带来的习惯，我没吃饭，组会开了三个多小时，组会的时候，认识了禹承轩，得他帮助，终于搞定了饭卡和校园网的事情，能够顺利吃上饭和洗澡了，之前几天一直没吃饭，下午的时候照了新生采集照，去了图书馆，问了北京烤鸭得事情，晚上通知明天要去市里开RISC-V中国区峰会，真的6，坐地铁去，明早六点就得起床，晚上六点再回来，真的6，本来报名时间都过了，大老板发话，小老板特别关照，没报名也让我们去了，当锻炼身体了吧</p><h1 id="今日反思"><a href="#今日反思" class="headerlink" title="今日反思"></a>今日反思</h1><p>孔子曰，每天都要反省自己，我就从今天开始每天得日记加入这个板块，今天我觉得做的不好的地方有以下几点，一个是起床起太晚了，应该六点左右就要出门锻炼，第二个是，对拉我一起汇报得师姐过去热情了，也就是话太多，虽然也没说几句话，以后非工作问题不和她交流，也不主动给他发消息，第三点就是今天知道峰会居然是坐地铁得时候，我在群里得发言体现了我的无语，下次不该这样子，少说点话，少发点言，不要把自己得情绪立即表达出来，也许事后复盘会觉得其实不该这么做。这就是今天得复盘，希望自己能加以改正</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记-8-21</title>
      <link href="/2023/08/21/%E6%97%A5%E8%AE%B08.21/"/>
      <url>/2023/08/21/%E6%97%A5%E8%AE%B08.21/</url>
      
        <content type="html"><![CDATA[<h1 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h1><p>今天早上去了图书馆看书，昨晚哭了很久眼睛有点疼，给陶俊余的消息迟迟没有回复，应该是不会回复我了，在图书馆学习的时候突然好怀念考研，好怀念川农，不知道是为什么，看电脑久了加上昨晚哭的眼睛疼，就抬头看向窗外，不知道为什么又想起了以后考研的时候，我坐陶俊余的侧面，看着她学累了抬头看窗的样子，无比的清晰，当时又好想好想她，其实我和她之间有过一段非常美好的回忆的，我后来在想，我这么喜欢她，为什么到最后对她有那么多职责和不满意呢，我看似乎生活中很多情侣都会这样，为什么会走到这一步呢，我当时的想法是，是什么我忘记了。</p><h1 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h1><p>今天实验室老板请我们吃饭，刘院长、金州老师和孙老师，定的是五点半，我走路过去的，本来想着提前两三分钟到，结果忘了考虑餐厅在七楼，坐电梯上去的时候，一层停一下一层停一下，结果最后我迟到了，进饭馆的时候那个小哥问我是几个人，有预约没，我以为吃饭就是那种进去找桌子，结果这家店只提供那中豪华大包间，包间里还有厕所那中，我推开包间大门，结果大家都做好了刘院长正在点菜，那一瞬间我怀疑自己是不是走错了，直到看到熟人，我快速的说着不好意思并找到一个空位置坐下来，坐下来的时候旁边是个女生，结果我缓过气抬头一看是金州老师，吓得我赶紧问好，老师说你是林福星，我说不是，我是邓福星，吃饭过程就不赘叙了，吃完饭和大家一起走回来的，有说有笑的，完事了好多人加我好友，因为我不主动加人家，大家还挺热情的，叫我好兄弟，那一刻突然就没那么想陶俊余了，晚上回宿舍前去图书馆收拾了东西，跑了步，本来想跑三公里，最后只跑了一公里多一点，每天都要坚持。要瘦下来，加油邓福星，最近感冒了，总流鼻涕，希望快点好</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-8-20</title>
      <link href="/2023/08/20/%E6%97%A5%E8%AE%B08-20/"/>
      <url>/2023/08/20/%E6%97%A5%E8%AE%B08-20/</url>
      
        <content type="html"><![CDATA[<p>今天下午送爸妈回家了，我一个人待着北京这地方，初来一个生疏的地方真的很多地方都不习惯，也感到很陌生，在努力的适应当中，其实真的很不习惯，昨天没写日记，其实昨天心里好多委屈，我其实真的不想来这学校的，我一点都不想的，我想退学，可是做不到，家里这么多的期盼，我真的好后悔好后悔，我不该填那个调剂的，我不该来北京散心的，我好想陶俊余啊，留我一个人在这个破地方，而且恋爱感情也没了，我真的好不喜欢，好讨厌我自己，我当时就是听到师兄那个成都EDA，不然我真的不会来，分手以来，我失去了生活的动力，完完全全的失去了生活的动力，我不想努力，可能别人会给我找好多理由努力，可对我来说，只有我的小家庭值得我努力，我最近好废好废，一点精神也打不起来，我好想陶俊余，今天在这里，北方的澡堂真的是惊呆我了，我习惯不了，早知道应该选南京农业的，不知道为什么走到了今天这一步，真的好失败</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日记 8-17</title>
      <link href="/2023/08/18/%E4%BB%8A%E6%97%A5%E4%BB%BD%E6%80%9D%E8%80%83/"/>
      <url>/2023/08/18/%E4%BB%8A%E6%97%A5%E4%BB%BD%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>现在是八月十八号早上，待会要去天坛，我在北京南站西铁营全季酒店，我在这里写下我最近一段时间的思考和领会。</p><p>最近一段时间我觉得我个人的情绪非常的浮躁，甚至很多时候都想要生气，我把我最近一些觉得愤怒的事情如实写在这里，并做自我刨析</p><p>这次和我爸妈来北京，我对爸爸产生过很多次生气的想法，在很多时候，他不跟我们一起，又或者说，他有一些显示个性但又不明显与组织冲突的事情，可我会为这些事情感到愤怒，主要是以下事项，我们在天安门看完升旗的时间是早上6点，之后十点才有毛主席纪念堂，在这个期间我们本来坐在一处，后来爸爸说他困了，就另外找了一个阴凉的地方去睡觉，后来打视频让我跟妈妈也过去，我想我生气是因为，我觉得爸爸没用听我的指挥，我想是这样的，我觉得她们什么都不懂，不该有自己的想法，因为老老实实的跟着我走，所以我会生气，我对妈妈说，说爸爸不服从组织，其实细细想来是爸爸的错吗，我想不是吧，是我太强势了，这在后来的一件事中体现的更明显了，我想起尝试看看毛主席纪念堂可不可以提前进，结果核验身份的时候说不可以，爸爸说他想溜进去，虽然工作人员对他说不可以，我对他对我说想溜进去感到愤怒，觉得他爱刷小聪明，对他的生气更胜了，对他眼神和态度很不好的说，不行，出来，最后他低着头出来，后来我们纪念堂存了包，这里解释下，毛纪念堂是不可以带包的，我妈妈的小包没存，我们存了包，爸爸说，刚才我们走的时候，一转身他就听到工作人员说十点的可以检票了，我虽然怀疑，但也许去试一试，过马路的时候我对他说，请你守规矩点，语气很不好，我爸看着我也有点生气说，我哪里不守规矩了，那一刻他看着我的时候，我就想起了陶俊余，想起来我们走的那天，我对陶俊余说，你还敢忤逆我，她对我说，我就忤逆了，多么似曾相识的一幕，那一刻我恍惚了，我陷入了深思中，我想我是强势的，我希望别人都听我的话，如果以我为主导的话，我太强势了，这导致了，其实爸爸的行为并没有很大的错，陶俊余以前也没用做什么很过分的事情，我依旧愤怒而且无法容忍，我想是我的问题，我觉得我这个方面需要改变，不能这样，我应该反省我自身，并且做出改变。</p><p>昨天很想很想陶俊余，很想联系她，不是想复合，就是很想联系她，还好忍住了，差点没忍住，文字都打到聊天框了，我们不同路了，早上起来的时候庆幸没打扰</p><p>来天安门的时候，好想和她一起来，和她一起牵手逛，可惜没机会了，我们不同路了，我应该让她安静做事</p><p>最近思考是很多的，也看了两本书，但因为不想碰电脑，一直没传上去，以后有感悟要及时传，免得想法丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>难受-邓福星一定要瘦下去好吗，求求你了</title>
      <link href="/2023/08/08/%E9%9A%BE%E5%8F%97/"/>
      <url>/2023/08/08/%E9%9A%BE%E5%8F%97/</url>
      
        <content type="html"><![CDATA[<p>今天是八月八号，是秋至了，十点的时候来了奶奶家，最近应该是胖了，我测体重的时候是155，比起我去成都之前又胖了五斤，我爸看到我第一句话就是，180斤了？后来我吃饭的时候，他又笑着看着我说我长成了猛将了，我听到这话心里真的很难受，我前两天已经开始决定控制体重了，我也不喜欢当一个胖子，完了奶奶又说我长的像猪一样，说的我真的很难受，我一个人收拾起书包上楼来了，想起来又很没出息的在这里哭，我也不知道我为什么哭，我不想别人说我胖，虽然这是真的，可是说的我心里跟刀割一样，之前回湖南前，二姑在抖音上问妈妈，问我瘦了没，唉，难受，也许陶俊余也嫌我胖吧，胖的丑的不温柔的我，确实应该被抛弃，不知道为什么这么难受，真的好难受，我用手机给自己照了好多张照片，看看自己究竟胖成什么样子了，又想起以前陶俊余说，这辈子没机会看到邓福星瘦的模样了，这两年真的一事无成，恋爱最后也失败了，体重也剧增，什么什么都不如意，像个废物一样，邓福星，争口气，瘦下去好吗，答应我求求你，瘦下去好吗，求求你了，不知道为什么，这么难受的时候，好想好想陶俊余，想跟她说，我又受委屈，写到这里，又哭的好厉害，真的过的挺失败的，邓福星，慢慢照顾好自己，回不去了，也没机会给陶俊余送秋天第一杯奶茶了</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快碎掉了</title>
      <link href="/2023/08/01/%E9%9A%8F%E6%83%B38.1/"/>
      <url>/2023/08/01/%E9%9A%8F%E6%83%B38.1/</url>
      
        <content type="html"><![CDATA[<p>最近真的真的快要碎掉了，刚才在床上痛哭的时候，又想去找陶俊余了，因为我遍及四周，我想她会懂我，做到电脑前才想起，其实陶俊余并不关心我的情绪，我的情绪对她来说是负担，她大概率会说，关他什么事吧，我的情绪怎样，跟陶俊余会有什么关系呢，她不会关心我的，复试失败的时候她想的尽快逃离我，辛亏刚没找她，不然又小丑了</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写给俊余的信</title>
      <link href="/2023/07/31/%E9%9A%8F%E6%83%B3/"/>
      <url>/2023/07/31/%E9%9A%8F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>见字如面俊余，一晃我们已经一个月零九天没有联系了，不知道你最近还好吗，我想你一定会好好照顾自己的，俊余，说实话，我后悔遇见了你，不是后悔我损失了什么，又或者我承受了什么伤害，我后悔的是，我遇上了你，追求了你，给你这两年的生涯带来了沉重的打击，给你增添了许多的痛苦，我们是2022年2月7日正式确立关系，与2023年6月21日正式结束了我们的关系，给你持续带来了一年零五个月的痛苦，我是不成熟的，幼稚的，极端的，我总以为我的驰骋之心价值万金，其实这玩意一点都不值钱，在我们第一次分手的时候，我就不该纠缠的，在那期间，我给你带来了数不胜数的痛苦，俊余，我不够了解你，今天我必须这样承认，回头望去，你比我成熟的多得多的多，在这段感情中，我烦的最严重的错误，就是我没有给到你足够的安全感，俊余，过去的事情，我不愿再提了，我想你现在一定开始了很美好的新生活，这封信，我今天在这里写，也许你一生都不会知道，也不会看见，俊余，我想对你说，对不起，我的自作聪明，自以为是害了你，没有我这个垃圾的存在，我想你未来的生活里，一定可以过的很好，很完美，衷心祝愿你找到一个很好的男孩子，他已经学会了如何去爱，他成熟而且体贴，我非常非常希望有人能替我治愈我所给你带来的伤害，祝你一定一定幸福，罪者邓福星为你祈祷<br>                              2023年，7月31日，早上七点</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随笔 7-30</title>
      <link href="/2023/07/30/%E6%80%9D%E8%80%83/"/>
      <url>/2023/07/30/%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>我今天意识到，我真的很爱生气，很容易生气，我过去很多年来似乎认为，生气才是有性格，生气才能体现一个人是有立场的，可我现在这是不对的，这样的生气，让我的家庭，我的恋爱，承受了许多负担，也让我自己经受了很多不该加给自己的委屈，不该生气了，生活的很多事情，其实不必在意，不必生气，身边人的唠叨不必在意，听听就过去了，生活的道理总是在事情过去了就懂了，不要发脾气，不要说脏话，邓福星，加油做到好吗，永远记住好吗，做一个忠于自己的，平和的，不要求他人的人，这才是你所追求的不是吗，回到出发的路吧，做一个平和的自己</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随笔 7-29</title>
      <link href="/2023/07/29/%E9%9A%8F%E7%AC%94-7.29/"/>
      <url>/2023/07/29/%E9%9A%8F%E7%AC%94-7.29/</url>
      
        <content type="html"><![CDATA[<p>陶俊余，我好想你，你会不会也能感受到呢，刚才又稀里糊涂的哭了一场，我只恨我能力不够，心性不够，不能解决问题，为你遮风避雨，这也是我不再去联系你的原因，我不想，我不想，我不想你跟我在一起过的不开心不快乐，我的存在不能让你变好，我只会伤害你，那我宁愿离开，如果有一天，我有能力，我觉得我自己能照顾好人了，我会回来再看看你的，可现在，我实在不能再给你带去痛苦了，祝你幸福哦，一定要幸福哦</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-7.28</title>
      <link href="/2023/07/28/7.28/"/>
      <url>/2023/07/28/7.28/</url>
      
        <content type="html"><![CDATA[<h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>今天的日记写了没保存，结果没了，这是写的第二遍，以后不谈感情啦，这是最后一期带着个标签，人家不要我啦，把聊天记录反反复复看了很多遍，放手吧阿星，分手太匆忙，完了祝她幸福，就在这里祝她幸福吧</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今天把汇报的PPT大致上做的差不多了，一些小细节上需要优化的地方明天再看吧，原本师姐约的今天晚上给我讲她的论文，但是她没找我，那我肯定也不会找她，毕竟我现在是能少干点少干点，没啥做事情的动力</p><h2 id="今日琐事"><a href="#今日琐事" class="headerlink" title="今日琐事"></a>今日琐事</h2><p>今天好像什么也没发生，吃饭，睡觉，玩手机，就这样简单的过去了，晚饭的时候下楼买了瓶啤酒，现在没酒晚上真是睡不着，今天又是凌晨五点才睡的差不多，现在没谈恋爱了，有认真在想要不要去读个博，反正以后结不结婚无所谓了，也没什么经济压力，去学校了研究下，争取读个清华的博士，哈哈哈，白日做梦，人总是要自己给自己一点好的期盼嘛，不然生活真的过的太苦，好像没什么要说的了，就这些了好像，ok，写到这里，上传完睡觉，邓福星，永远永远不要放弃，我知道你很累，我给你时间，慢慢的一点一点的爬起来吧，我很多年前好像也对自己这样说过，突然涌上来的回忆，加油</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-7.27</title>
      <link href="/2023/07/28/7.27/"/>
      <url>/2023/07/28/7.27/</url>
      
        <content type="html"><![CDATA[<h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>   凌晨五点才睡着，可能因为这两天没喝酒？，所以即使身体真的很累，意识还是清醒的痛苦着，所以一直睡不着，今天发现她开了一个黄钻，难道是因为看被挡访客？我前几天盯着她qq主页面看的时候，手滑点了空间，留下了记录，我当时就开了黄钻删记录，不知道有用没用，手机上不知道为什么qq聊天记录还是有，最近的是6月15号，她对我说，她正变得越来越差，说我说她哪里都好是违心，不知道为什么，看到这段话又觉得心很痛，写了一个文件里面罗列了她得各种优点，想让方姐发给她，犹豫得时候，又想到了她坚决分手说的那些话，让我不要再拉扯了，放过她，文件于是写完又删了，不要拉扯别人了，给她她想要的吧，男人咬咬牙就过去了，最近老是想到她问我，我是不是因为她很好追才追得她，这句话她问了我好多遍，我心里也回答了好多遍，我很想告诉她，其实要是我对每个人都像对她那样，虽然我个人条件并不算好，可真诚难得吧，这个时代，真诚难得吧，用我当时的真诚，真诚多稀缺，去追大部分人，加上我并不是直男，大部分人都能追上吧，如果只是为了谈恋爱，有必要等到她出现吗，她问了好几遍这种话，那就当是吧，就是她很好追我才追的她。她有一句话其实值得我学习，他说，我不解释，你怎么想的我解释再多也没用了，这算不算冷暴力，让我想起了邓仁杰，他很帅，也很喜欢他前女友，最后他俩还是分了，当时我问邓仁杰，为啥分手，他说，因为他什么都说，但女孩子什么都不说，怎么说都是你不懂算了什么的，当时我不懂这句话，现在我理解了，跟我差不多吧，后来她前女友光速谈了下一个，我在想，更爱的人才想多说一点吧，因为生怕说不清楚，其实像那种什么我觉得说再多都没用的那种，都是渣，差点又把他妈的打出来了，不能再说脏话了，其实我的理解也许不对，唉，给我选，我也选做那个不说话的人，说话谁不累，谁喜欢说话，又说了唉，哥们这场恋爱真是长教训了，从前都是哥们话少，立志做一字千钧的人，结果谈个恋爱，变成八婆了，现在抱怨那么多有什么用呢，给哥们再一次机会跟她说话，哥们第一要说的，还是对不起，没照顾好你，有些事情我真的过不去，我为什么要晚上把门反锁呢，让她哭着在外面敲门，我知道当时我自己也是生气，可是不该这么做的，这件事情哥们无法原谅我自己，另外就是那天晚上逼她屈服那件事，她那膝盖一晚，那晚上，我这辈子都原谅不了自己，每次想到这些事情，我都很愧疚，还是不要去打扰女孩子了，没有我她会过的更好，以前我认识她的时候，是想照顾好她的，我尝试了，完全失败，还让他变得更加不好了，所以不要纠缠了，没有我她会更好，也许我们真的不合适吧，我最近总是想到我从13楼跳下去，而且每次都很怕，我知道自己当时是真的痛苦的有跳楼的冲动的，好多次我都模拟自己跳下去了，这也是被她甩后，那么快打包回去的原因，我太怕的，怕我自己纵身一跃，现在有时候晚上回忆到这一部分，都心惊胆颤。放手吧，放过她，我超级讨厌拉扯这个词的，拉扯应该是有意的吧，有意之举叫拉扯？她总这么说我，我真的超级讨厌</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>一点都不像学习，今天学习不到三个小时，论文看完了，ppt都没做完，还是觉得身体很疲惫，而精神却清晰的痛苦，所以真的写不下去作业，写日记还挺好，不用动脑子，明天要好好写作业</p><h2 id="今日琐事"><a href="#今日琐事" class="headerlink" title="今日琐事"></a>今日琐事</h2><p>早上起来，冯一航就问我实验的事，回答了些他的问题，一天反正只吃一顿，今天下午一点多才醒，五点才睡的嘛，最近福建这个台风登陆，早上睡觉的时候，那个风呼呼呼的声音真的很打扰人睡觉，下午看了论文，五点左右的时候坐电梯下楼走了走，福建这个风真的很大，我在下面吹了很久的风，我很喜欢吹风，我觉得风好像在拥抱我，拥抱一个受伤的孩子，风很大，大到能推着我走，我也很喜欢，有人在助力我走了，后来风雨交加，我在雨里待了很久，其实我真的很脆弱，晚上八点就上床睡觉了，结果又没睡着，写完这个日记，继续去床上了，希望今晚能睡好点，网上诊断了下是重度抑郁的初级阶段，比中度抑郁严重一点点那种，我也好想告诉大家我生病了啊，可是我不能，自己扛过去就好了，我不需要别人照顾。就写到这了，晚安</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的一些思考-7.26</title>
      <link href="/2023/07/28/7.26/"/>
      <url>/2023/07/28/7.26/</url>
      
        <content type="html"><![CDATA[<h2 id="情感"><a href="#情感" class="headerlink" title="情感"></a>情感</h2><p>  今早四点多才睡着，还是为感情的事情觉得很痛苦，晚上十点多很困了，但是睡了一会又觉得痛苦，所以又起来捣鼓博客，继续优化了下</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>  今天学习没学，一直在捣鼓博客，不过好在博客捣鼓的应该是可以了，就这样，也不写什么技术文，主要是写一些日记啥的，完全够用了，最近压力其实我自己也知道很大，应该是心态出问题了吧，凌晨没睡着的时候，想起昨晚开会老师的声音甚至都觉得恐怖，怕上学已经到了这个地步，甚至有了退学的念头，这研究生还没上就这样了，心态应该是出问题了，要好好调整</p><p>目前的学习任务还挺多的，第五周的作业29号交，我还没看，其实是有点不太想看的，想摆烂，又想起昨天开会老师的要求了，唉，我自知是达不到老师的要求的，所以想逃避，原先以为，老四应该没这么多学生，结果老师这么多学生，我觉得我做个普通人，争取毕业就好了，千万不要想着出什么风头，8月1号轮到我汇报了，四十页的论文，现在只看了三页，老天救救，真的一点不想动，ppt还没做，想死，28号师姐说要找我讨论课题，参与她那个论文，这个应该压力没那么大，应该能随便应付过去吧，好快就要开学了，助学贷款还没弄，来福建一个多月了，厦门还没去，不知道还能不能去，对了，一定要改变骂人这个习惯，先通过写文字来吧</p><h2 id="今日琐事"><a href="#今日琐事" class="headerlink" title="今日琐事"></a>今日琐事</h2><p>今天跟我妈出去买菜，结果她对面宿舍那对年轻夫妻开车也去买菜，路上碰到了，我惊讶她们怎么就买车了，这厂里的钱也没这么好赚吧，突然有点羡慕，其实感觉智商没那么高其实好一点，老老实实娶一个普普通通的女孩，过一辈子也没关系，夫妻两齐心奋斗真的挺重要的，今天爸爸跟妈妈打视频，感觉其实，两人吵归吵，嫌弃归嫌弃，但可能他们之间已经有了一种在这个孤单的人世间，知道彼此是一个特殊的连结，相依为命的感觉吧，晚上看视频，陈丹青老师说，哥们扛着，没问题的，只要不死就扛着，要死的事一定就躲开，邓福星，扛着，没问题的，加油呀<br>对了，陶俊余最近什么平台都没更新，应该是在认真学习吧，刚才下意识的又打出了，唉，不行，以后不能打这个词，要振作，我也要好好学习，不能被甩了，还没志气，上次方姐说，难受的时候就感受难受吧，感受了一下，知道为什么人们说，心坠入了深渊，真的在感受身体和心脏下沉的时候，不知道心能下沉多远，真的感觉就是个无尽的深渊，挺神奇的，写完了，睡觉吧，要加油，自己要加油，要挽救自己，自救，你可以的，加油加油</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
